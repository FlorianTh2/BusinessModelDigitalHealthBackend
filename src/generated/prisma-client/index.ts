// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  canvas: (where?: CanvasWhereInput) => Promise<boolean>;
  channel: (where?: ChannelWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  costStructure: (where?: CostStructureWhereInput) => Promise<boolean>;
  customerRelationship: (
    where?: CustomerRelationshipWhereInput
  ) => Promise<boolean>;
  customerSegment: (where?: CustomerSegmentWhereInput) => Promise<boolean>;
  keyActitvity: (where?: KeyActitvityWhereInput) => Promise<boolean>;
  keyPartner: (where?: KeyPartnerWhereInput) => Promise<boolean>;
  keyResource: (where?: KeyResourceWhereInput) => Promise<boolean>;
  pattern: (where?: PatternWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  revenueStream: (where?: RevenueStreamWhereInput) => Promise<boolean>;
  table: (where?: TableWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  valueProposition: (where?: ValuePropositionWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  canvas: (where: CanvasWhereUniqueInput) => CanvasNullablePromise;
  canvases: (args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Canvas>;
  canvasesConnection: (args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CanvasConnectionPromise;
  channel: (where: ChannelWhereUniqueInput) => ChannelNullablePromise;
  channels: (args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Channel>;
  channelsConnection: (args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChannelConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  costStructure: (
    where: CostStructureWhereUniqueInput
  ) => CostStructureNullablePromise;
  costStructures: (args?: {
    where?: CostStructureWhereInput;
    orderBy?: CostStructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CostStructure>;
  costStructuresConnection: (args?: {
    where?: CostStructureWhereInput;
    orderBy?: CostStructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CostStructureConnectionPromise;
  customerRelationship: (
    where: CustomerRelationshipWhereUniqueInput
  ) => CustomerRelationshipNullablePromise;
  customerRelationships: (args?: {
    where?: CustomerRelationshipWhereInput;
    orderBy?: CustomerRelationshipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerRelationship>;
  customerRelationshipsConnection: (args?: {
    where?: CustomerRelationshipWhereInput;
    orderBy?: CustomerRelationshipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerRelationshipConnectionPromise;
  customerSegment: (
    where: CustomerSegmentWhereUniqueInput
  ) => CustomerSegmentNullablePromise;
  customerSegments: (args?: {
    where?: CustomerSegmentWhereInput;
    orderBy?: CustomerSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerSegment>;
  customerSegmentsConnection: (args?: {
    where?: CustomerSegmentWhereInput;
    orderBy?: CustomerSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerSegmentConnectionPromise;
  keyActitvity: (
    where: KeyActitvityWhereUniqueInput
  ) => KeyActitvityNullablePromise;
  keyActitvities: (args?: {
    where?: KeyActitvityWhereInput;
    orderBy?: KeyActitvityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<KeyActitvity>;
  keyActitvitiesConnection: (args?: {
    where?: KeyActitvityWhereInput;
    orderBy?: KeyActitvityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => KeyActitvityConnectionPromise;
  keyPartner: (where: KeyPartnerWhereUniqueInput) => KeyPartnerNullablePromise;
  keyPartners: (args?: {
    where?: KeyPartnerWhereInput;
    orderBy?: KeyPartnerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<KeyPartner>;
  keyPartnersConnection: (args?: {
    where?: KeyPartnerWhereInput;
    orderBy?: KeyPartnerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => KeyPartnerConnectionPromise;
  keyResource: (
    where: KeyResourceWhereUniqueInput
  ) => KeyResourceNullablePromise;
  keyResources: (args?: {
    where?: KeyResourceWhereInput;
    orderBy?: KeyResourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<KeyResource>;
  keyResourcesConnection: (args?: {
    where?: KeyResourceWhereInput;
    orderBy?: KeyResourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => KeyResourceConnectionPromise;
  pattern: (where: PatternWhereUniqueInput) => PatternNullablePromise;
  patterns: (args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pattern>;
  patternsConnection: (args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PatternConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectNullablePromise;
  projects: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Project>;
  projectsConnection: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectConnectionPromise;
  revenueStream: (
    where: RevenueStreamWhereUniqueInput
  ) => RevenueStreamNullablePromise;
  revenueStreams: (args?: {
    where?: RevenueStreamWhereInput;
    orderBy?: RevenueStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RevenueStream>;
  revenueStreamsConnection: (args?: {
    where?: RevenueStreamWhereInput;
    orderBy?: RevenueStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RevenueStreamConnectionPromise;
  table: (where: TableWhereUniqueInput) => TableNullablePromise;
  tables: (args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Table>;
  tablesConnection: (args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TableConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  valueProposition: (
    where: ValuePropositionWhereUniqueInput
  ) => ValuePropositionNullablePromise;
  valuePropositions: (args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ValueProposition>;
  valuePropositionsConnection: (args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ValuePropositionConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCanvas: (data: CanvasCreateInput) => CanvasPromise;
  updateCanvas: (args: {
    data: CanvasUpdateInput;
    where: CanvasWhereUniqueInput;
  }) => CanvasPromise;
  updateManyCanvases: (args: {
    data: CanvasUpdateManyMutationInput;
    where?: CanvasWhereInput;
  }) => BatchPayloadPromise;
  upsertCanvas: (args: {
    where: CanvasWhereUniqueInput;
    create: CanvasCreateInput;
    update: CanvasUpdateInput;
  }) => CanvasPromise;
  deleteCanvas: (where: CanvasWhereUniqueInput) => CanvasPromise;
  deleteManyCanvases: (where?: CanvasWhereInput) => BatchPayloadPromise;
  createChannel: (data: ChannelCreateInput) => ChannelPromise;
  updateChannel: (args: {
    data: ChannelUpdateInput;
    where: ChannelWhereUniqueInput;
  }) => ChannelPromise;
  updateManyChannels: (args: {
    data: ChannelUpdateManyMutationInput;
    where?: ChannelWhereInput;
  }) => BatchPayloadPromise;
  upsertChannel: (args: {
    where: ChannelWhereUniqueInput;
    create: ChannelCreateInput;
    update: ChannelUpdateInput;
  }) => ChannelPromise;
  deleteChannel: (where: ChannelWhereUniqueInput) => ChannelPromise;
  deleteManyChannels: (where?: ChannelWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createCostStructure: (data: CostStructureCreateInput) => CostStructurePromise;
  updateCostStructure: (args: {
    data: CostStructureUpdateInput;
    where: CostStructureWhereUniqueInput;
  }) => CostStructurePromise;
  updateManyCostStructures: (args: {
    data: CostStructureUpdateManyMutationInput;
    where?: CostStructureWhereInput;
  }) => BatchPayloadPromise;
  upsertCostStructure: (args: {
    where: CostStructureWhereUniqueInput;
    create: CostStructureCreateInput;
    update: CostStructureUpdateInput;
  }) => CostStructurePromise;
  deleteCostStructure: (
    where: CostStructureWhereUniqueInput
  ) => CostStructurePromise;
  deleteManyCostStructures: (
    where?: CostStructureWhereInput
  ) => BatchPayloadPromise;
  createCustomerRelationship: (
    data: CustomerRelationshipCreateInput
  ) => CustomerRelationshipPromise;
  updateCustomerRelationship: (args: {
    data: CustomerRelationshipUpdateInput;
    where: CustomerRelationshipWhereUniqueInput;
  }) => CustomerRelationshipPromise;
  updateManyCustomerRelationships: (args: {
    data: CustomerRelationshipUpdateManyMutationInput;
    where?: CustomerRelationshipWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerRelationship: (args: {
    where: CustomerRelationshipWhereUniqueInput;
    create: CustomerRelationshipCreateInput;
    update: CustomerRelationshipUpdateInput;
  }) => CustomerRelationshipPromise;
  deleteCustomerRelationship: (
    where: CustomerRelationshipWhereUniqueInput
  ) => CustomerRelationshipPromise;
  deleteManyCustomerRelationships: (
    where?: CustomerRelationshipWhereInput
  ) => BatchPayloadPromise;
  createCustomerSegment: (
    data: CustomerSegmentCreateInput
  ) => CustomerSegmentPromise;
  updateCustomerSegment: (args: {
    data: CustomerSegmentUpdateInput;
    where: CustomerSegmentWhereUniqueInput;
  }) => CustomerSegmentPromise;
  updateManyCustomerSegments: (args: {
    data: CustomerSegmentUpdateManyMutationInput;
    where?: CustomerSegmentWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerSegment: (args: {
    where: CustomerSegmentWhereUniqueInput;
    create: CustomerSegmentCreateInput;
    update: CustomerSegmentUpdateInput;
  }) => CustomerSegmentPromise;
  deleteCustomerSegment: (
    where: CustomerSegmentWhereUniqueInput
  ) => CustomerSegmentPromise;
  deleteManyCustomerSegments: (
    where?: CustomerSegmentWhereInput
  ) => BatchPayloadPromise;
  createKeyActitvity: (data: KeyActitvityCreateInput) => KeyActitvityPromise;
  updateKeyActitvity: (args: {
    data: KeyActitvityUpdateInput;
    where: KeyActitvityWhereUniqueInput;
  }) => KeyActitvityPromise;
  updateManyKeyActitvities: (args: {
    data: KeyActitvityUpdateManyMutationInput;
    where?: KeyActitvityWhereInput;
  }) => BatchPayloadPromise;
  upsertKeyActitvity: (args: {
    where: KeyActitvityWhereUniqueInput;
    create: KeyActitvityCreateInput;
    update: KeyActitvityUpdateInput;
  }) => KeyActitvityPromise;
  deleteKeyActitvity: (
    where: KeyActitvityWhereUniqueInput
  ) => KeyActitvityPromise;
  deleteManyKeyActitvities: (
    where?: KeyActitvityWhereInput
  ) => BatchPayloadPromise;
  createKeyPartner: (data: KeyPartnerCreateInput) => KeyPartnerPromise;
  updateKeyPartner: (args: {
    data: KeyPartnerUpdateInput;
    where: KeyPartnerWhereUniqueInput;
  }) => KeyPartnerPromise;
  updateManyKeyPartners: (args: {
    data: KeyPartnerUpdateManyMutationInput;
    where?: KeyPartnerWhereInput;
  }) => BatchPayloadPromise;
  upsertKeyPartner: (args: {
    where: KeyPartnerWhereUniqueInput;
    create: KeyPartnerCreateInput;
    update: KeyPartnerUpdateInput;
  }) => KeyPartnerPromise;
  deleteKeyPartner: (where: KeyPartnerWhereUniqueInput) => KeyPartnerPromise;
  deleteManyKeyPartners: (where?: KeyPartnerWhereInput) => BatchPayloadPromise;
  createKeyResource: (data: KeyResourceCreateInput) => KeyResourcePromise;
  updateKeyResource: (args: {
    data: KeyResourceUpdateInput;
    where: KeyResourceWhereUniqueInput;
  }) => KeyResourcePromise;
  updateManyKeyResources: (args: {
    data: KeyResourceUpdateManyMutationInput;
    where?: KeyResourceWhereInput;
  }) => BatchPayloadPromise;
  upsertKeyResource: (args: {
    where: KeyResourceWhereUniqueInput;
    create: KeyResourceCreateInput;
    update: KeyResourceUpdateInput;
  }) => KeyResourcePromise;
  deleteKeyResource: (where: KeyResourceWhereUniqueInput) => KeyResourcePromise;
  deleteManyKeyResources: (
    where?: KeyResourceWhereInput
  ) => BatchPayloadPromise;
  createPattern: (data: PatternCreateInput) => PatternPromise;
  updatePattern: (args: {
    data: PatternUpdateInput;
    where: PatternWhereUniqueInput;
  }) => PatternPromise;
  updateManyPatterns: (args: {
    data: PatternUpdateManyMutationInput;
    where?: PatternWhereInput;
  }) => BatchPayloadPromise;
  upsertPattern: (args: {
    where: PatternWhereUniqueInput;
    create: PatternCreateInput;
    update: PatternUpdateInput;
  }) => PatternPromise;
  deletePattern: (where: PatternWhereUniqueInput) => PatternPromise;
  deleteManyPatterns: (where?: PatternWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (args: {
    data: ProjectUpdateInput;
    where: ProjectWhereUniqueInput;
  }) => ProjectPromise;
  updateManyProjects: (args: {
    data: ProjectUpdateManyMutationInput;
    where?: ProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertProject: (args: {
    where: ProjectWhereUniqueInput;
    create: ProjectCreateInput;
    update: ProjectUpdateInput;
  }) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createRevenueStream: (data: RevenueStreamCreateInput) => RevenueStreamPromise;
  updateRevenueStream: (args: {
    data: RevenueStreamUpdateInput;
    where: RevenueStreamWhereUniqueInput;
  }) => RevenueStreamPromise;
  updateManyRevenueStreams: (args: {
    data: RevenueStreamUpdateManyMutationInput;
    where?: RevenueStreamWhereInput;
  }) => BatchPayloadPromise;
  upsertRevenueStream: (args: {
    where: RevenueStreamWhereUniqueInput;
    create: RevenueStreamCreateInput;
    update: RevenueStreamUpdateInput;
  }) => RevenueStreamPromise;
  deleteRevenueStream: (
    where: RevenueStreamWhereUniqueInput
  ) => RevenueStreamPromise;
  deleteManyRevenueStreams: (
    where?: RevenueStreamWhereInput
  ) => BatchPayloadPromise;
  createTable: (data: TableCreateInput) => TablePromise;
  updateTable: (args: {
    data: TableUpdateInput;
    where: TableWhereUniqueInput;
  }) => TablePromise;
  upsertTable: (args: {
    where: TableWhereUniqueInput;
    create: TableCreateInput;
    update: TableUpdateInput;
  }) => TablePromise;
  deleteTable: (where: TableWhereUniqueInput) => TablePromise;
  deleteManyTables: (where?: TableWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createValueProposition: (
    data: ValuePropositionCreateInput
  ) => ValuePropositionPromise;
  updateValueProposition: (args: {
    data: ValuePropositionUpdateInput;
    where: ValuePropositionWhereUniqueInput;
  }) => ValuePropositionPromise;
  updateManyValuePropositions: (args: {
    data: ValuePropositionUpdateManyMutationInput;
    where?: ValuePropositionWhereInput;
  }) => BatchPayloadPromise;
  upsertValueProposition: (args: {
    where: ValuePropositionWhereUniqueInput;
    create: ValuePropositionCreateInput;
    update: ValuePropositionUpdateInput;
  }) => ValuePropositionPromise;
  deleteValueProposition: (
    where: ValuePropositionWhereUniqueInput
  ) => ValuePropositionPromise;
  deleteManyValuePropositions: (
    where?: ValuePropositionWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  canvas: (
    where?: CanvasSubscriptionWhereInput
  ) => CanvasSubscriptionPayloadSubscription;
  channel: (
    where?: ChannelSubscriptionWhereInput
  ) => ChannelSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  costStructure: (
    where?: CostStructureSubscriptionWhereInput
  ) => CostStructureSubscriptionPayloadSubscription;
  customerRelationship: (
    where?: CustomerRelationshipSubscriptionWhereInput
  ) => CustomerRelationshipSubscriptionPayloadSubscription;
  customerSegment: (
    where?: CustomerSegmentSubscriptionWhereInput
  ) => CustomerSegmentSubscriptionPayloadSubscription;
  keyActitvity: (
    where?: KeyActitvitySubscriptionWhereInput
  ) => KeyActitvitySubscriptionPayloadSubscription;
  keyPartner: (
    where?: KeyPartnerSubscriptionWhereInput
  ) => KeyPartnerSubscriptionPayloadSubscription;
  keyResource: (
    where?: KeyResourceSubscriptionWhereInput
  ) => KeyResourceSubscriptionPayloadSubscription;
  pattern: (
    where?: PatternSubscriptionWhereInput
  ) => PatternSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  revenueStream: (
    where?: RevenueStreamSubscriptionWhereInput
  ) => RevenueStreamSubscriptionPayloadSubscription;
  table: (
    where?: TableSubscriptionWhereInput
  ) => TableSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  valueProposition: (
    where?: ValuePropositionSubscriptionWhereInput
  ) => ValuePropositionSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Role = "USER" | "ADMIN";

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CanvasOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PatternOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type KeyPartnerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TableOrderByInput = "id_ASC" | "id_DESC";

export type RevenueStreamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type KeyActitvityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerRelationshipOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ValuePropositionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CostStructureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerSegmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type KeyResourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ChannelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "role_ASC"
  | "role_DESC"
  | "password_ASC"
  | "password_DESC"
  | "verificationCode_ASC"
  | "verificationCode_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CanvasWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user_id?: Maybe<UserWhereInput>;
  canvas_ids_every?: Maybe<CanvasWhereInput>;
  canvas_ids_some?: Maybe<CanvasWhereInput>;
  canvas_ids_none?: Maybe<CanvasWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  OR?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  NOT?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  project_ids_every?: Maybe<ProjectWhereInput>;
  project_ids_some?: Maybe<ProjectWhereInput>;
  project_ids_none?: Maybe<ProjectWhereInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verificationCode_not?: Maybe<String>;
  verificationCode_in?: Maybe<String[] | String>;
  verificationCode_not_in?: Maybe<String[] | String>;
  verificationCode_lt?: Maybe<String>;
  verificationCode_lte?: Maybe<String>;
  verificationCode_gt?: Maybe<String>;
  verificationCode_gte?: Maybe<String>;
  verificationCode_contains?: Maybe<String>;
  verificationCode_not_contains?: Maybe<String>;
  verificationCode_starts_with?: Maybe<String>;
  verificationCode_not_starts_with?: Maybe<String>;
  verificationCode_ends_with?: Maybe<String>;
  verificationCode_not_ends_with?: Maybe<String>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CanvasWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  project_id?: Maybe<ProjectWhereInput>;
  pattern_ids_every?: Maybe<PatternWhereInput>;
  pattern_ids_some?: Maybe<PatternWhereInput>;
  pattern_ids_none?: Maybe<PatternWhereInput>;
  table_id?: Maybe<TableWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CanvasWhereInput[] | CanvasWhereInput>;
  OR?: Maybe<CanvasWhereInput[] | CanvasWhereInput>;
  NOT?: Maybe<CanvasWhereInput[] | CanvasWhereInput>;
}

export interface PatternWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  canvas_ids_every?: Maybe<CanvasWhereInput>;
  canvas_ids_some?: Maybe<CanvasWhereInput>;
  canvas_ids_none?: Maybe<CanvasWhereInput>;
  table_id?: Maybe<TableWhereInput>;
  company_ids_every?: Maybe<CompanyWhereInput>;
  company_ids_some?: Maybe<CompanyWhereInput>;
  company_ids_none?: Maybe<CompanyWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PatternWhereInput[] | PatternWhereInput>;
  OR?: Maybe<PatternWhereInput[] | PatternWhereInput>;
  NOT?: Maybe<PatternWhereInput[] | PatternWhereInput>;
}

export interface TableWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  key_partner_entry_ids_every?: Maybe<KeyPartnerWhereInput>;
  key_partner_entry_ids_some?: Maybe<KeyPartnerWhereInput>;
  key_partner_entry_ids_none?: Maybe<KeyPartnerWhereInput>;
  reventue_stream_entry_ids_every?: Maybe<RevenueStreamWhereInput>;
  reventue_stream_entry_ids_some?: Maybe<RevenueStreamWhereInput>;
  reventue_stream_entry_ids_none?: Maybe<RevenueStreamWhereInput>;
  key_activity_entry_ids_every?: Maybe<KeyActitvityWhereInput>;
  key_activity_entry_ids_some?: Maybe<KeyActitvityWhereInput>;
  key_activity_entry_ids_none?: Maybe<KeyActitvityWhereInput>;
  customer_relationship_entry_ids_every?: Maybe<CustomerRelationshipWhereInput>;
  customer_relationship_entry_ids_some?: Maybe<CustomerRelationshipWhereInput>;
  customer_relationship_entry_ids_none?: Maybe<CustomerRelationshipWhereInput>;
  value_proposition_entry_ids_every?: Maybe<ValuePropositionWhereInput>;
  value_proposition_entry_ids_some?: Maybe<ValuePropositionWhereInput>;
  value_proposition_entry_ids_none?: Maybe<ValuePropositionWhereInput>;
  cost_structure_entry_ids_every?: Maybe<CostStructureWhereInput>;
  cost_structure_entry_ids_some?: Maybe<CostStructureWhereInput>;
  cost_structure_entry_ids_none?: Maybe<CostStructureWhereInput>;
  customer_segment_entry_ids_every?: Maybe<CustomerSegmentWhereInput>;
  customer_segment_entry_ids_some?: Maybe<CustomerSegmentWhereInput>;
  customer_segment_entry_ids_none?: Maybe<CustomerSegmentWhereInput>;
  key_resource_entry_ids_every?: Maybe<KeyResourceWhereInput>;
  key_resource_entry_ids_some?: Maybe<KeyResourceWhereInput>;
  key_resource_entry_ids_none?: Maybe<KeyResourceWhereInput>;
  channel_entry_ids_every?: Maybe<ChannelWhereInput>;
  channel_entry_ids_some?: Maybe<ChannelWhereInput>;
  channel_entry_ids_none?: Maybe<ChannelWhereInput>;
  AND?: Maybe<TableWhereInput[] | TableWhereInput>;
  OR?: Maybe<TableWhereInput[] | TableWhereInput>;
  NOT?: Maybe<TableWhereInput[] | TableWhereInput>;
}

export interface KeyPartnerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<KeyPartnerWhereInput[] | KeyPartnerWhereInput>;
  OR?: Maybe<KeyPartnerWhereInput[] | KeyPartnerWhereInput>;
  NOT?: Maybe<KeyPartnerWhereInput[] | KeyPartnerWhereInput>;
}

export interface RevenueStreamWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RevenueStreamWhereInput[] | RevenueStreamWhereInput>;
  OR?: Maybe<RevenueStreamWhereInput[] | RevenueStreamWhereInput>;
  NOT?: Maybe<RevenueStreamWhereInput[] | RevenueStreamWhereInput>;
}

export interface KeyActitvityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<KeyActitvityWhereInput[] | KeyActitvityWhereInput>;
  OR?: Maybe<KeyActitvityWhereInput[] | KeyActitvityWhereInput>;
  NOT?: Maybe<KeyActitvityWhereInput[] | KeyActitvityWhereInput>;
}

export interface CustomerRelationshipWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CustomerRelationshipWhereInput[] | CustomerRelationshipWhereInput
  >;
  OR?: Maybe<CustomerRelationshipWhereInput[] | CustomerRelationshipWhereInput>;
  NOT?: Maybe<
    CustomerRelationshipWhereInput[] | CustomerRelationshipWhereInput
  >;
}

export interface ValuePropositionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ValuePropositionWhereInput[] | ValuePropositionWhereInput>;
  OR?: Maybe<ValuePropositionWhereInput[] | ValuePropositionWhereInput>;
  NOT?: Maybe<ValuePropositionWhereInput[] | ValuePropositionWhereInput>;
}

export interface CostStructureWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CostStructureWhereInput[] | CostStructureWhereInput>;
  OR?: Maybe<CostStructureWhereInput[] | CostStructureWhereInput>;
  NOT?: Maybe<CostStructureWhereInput[] | CostStructureWhereInput>;
}

export interface CustomerSegmentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerSegmentWhereInput[] | CustomerSegmentWhereInput>;
  OR?: Maybe<CustomerSegmentWhereInput[] | CustomerSegmentWhereInput>;
  NOT?: Maybe<CustomerSegmentWhereInput[] | CustomerSegmentWhereInput>;
}

export interface KeyResourceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<KeyResourceWhereInput[] | KeyResourceWhereInput>;
  OR?: Maybe<KeyResourceWhereInput[] | KeyResourceWhereInput>;
  NOT?: Maybe<KeyResourceWhereInput[] | KeyResourceWhereInput>;
}

export interface ChannelWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
  OR?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
  NOT?: Maybe<ChannelWhereInput[] | ChannelWhereInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  pattern_ids_every?: Maybe<PatternWhereInput>;
  pattern_ids_some?: Maybe<PatternWhereInput>;
  pattern_ids_none?: Maybe<PatternWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export type ChannelWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CostStructureWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CustomerRelationshipWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CustomerSegmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type KeyActitvityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type KeyPartnerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type KeyResourceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PatternWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RevenueStreamWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TableWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type ValuePropositionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CanvasCreateInput {
  id?: Maybe<ID_Input>;
  project_id: ProjectCreateOneWithoutCanvas_idsInput;
  pattern_ids?: Maybe<PatternCreateManyWithoutCanvas_idsInput>;
  table_id: TableCreateOneInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ProjectCreateOneWithoutCanvas_idsInput {
  create?: Maybe<ProjectCreateWithoutCanvas_idsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface ProjectCreateWithoutCanvas_idsInput {
  id?: Maybe<ID_Input>;
  user_id: UserCreateOneWithoutProject_idsInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface UserCreateOneWithoutProject_idsInput {
  create?: Maybe<UserCreateWithoutProject_idsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutProject_idsInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  email: String;
  role?: Maybe<Role>;
  password: String;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserCreateOneWithoutUpdatedByInput>;
}

export interface UserCreateOneWithoutUpdatedByInput {
  create?: Maybe<UserCreateWithoutUpdatedByInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutUpdatedByInput {
  id?: Maybe<ID_Input>;
  project_ids?: Maybe<ProjectCreateManyWithoutUser_idInput>;
  firstName: String;
  lastName: String;
  email: String;
  role?: Maybe<Role>;
  password: String;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
}

export interface ProjectCreateManyWithoutUser_idInput {
  create?: Maybe<
    ProjectCreateWithoutUser_idInput[] | ProjectCreateWithoutUser_idInput
  >;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
}

export interface ProjectCreateWithoutUser_idInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutProject_idInput>;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CanvasCreateManyWithoutProject_idInput {
  create?: Maybe<
    CanvasCreateWithoutProject_idInput[] | CanvasCreateWithoutProject_idInput
  >;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
}

export interface CanvasCreateWithoutProject_idInput {
  id?: Maybe<ID_Input>;
  pattern_ids?: Maybe<PatternCreateManyWithoutCanvas_idsInput>;
  table_id: TableCreateOneInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface PatternCreateManyWithoutCanvas_idsInput {
  create?: Maybe<
    PatternCreateWithoutCanvas_idsInput[] | PatternCreateWithoutCanvas_idsInput
  >;
  connect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
}

export interface PatternCreateWithoutCanvas_idsInput {
  id?: Maybe<ID_Input>;
  table_id: TableCreateOneInput;
  company_ids?: Maybe<CompanyCreateManyWithoutPattern_idsInput>;
  name: String;
  description?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateOneInput {
  create?: Maybe<TableCreateInput>;
  connect?: Maybe<TableWhereUniqueInput>;
}

export interface TableCreateInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface KeyPartnerCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | KeyPartnerCreateWithoutTable_idsInput[]
    | KeyPartnerCreateWithoutTable_idsInput
  >;
  connect?: Maybe<KeyPartnerWhereUniqueInput[] | KeyPartnerWhereUniqueInput>;
}

export interface KeyPartnerCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  project_ids?: Maybe<ProjectCreateManyWithoutUser_idInput>;
  firstName: String;
  lastName: String;
  email: String;
  role?: Maybe<Role>;
  password: String;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserCreateOneWithoutUpdatedByInput>;
}

export interface RevenueStreamCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | RevenueStreamCreateWithoutTable_idsInput[]
    | RevenueStreamCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    RevenueStreamWhereUniqueInput[] | RevenueStreamWhereUniqueInput
  >;
}

export interface RevenueStreamCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface KeyActitvityCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | KeyActitvityCreateWithoutTable_idsInput[]
    | KeyActitvityCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    KeyActitvityWhereUniqueInput[] | KeyActitvityWhereUniqueInput
  >;
}

export interface KeyActitvityCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CustomerRelationshipCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | CustomerRelationshipCreateWithoutTable_idsInput[]
    | CustomerRelationshipCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    | CustomerRelationshipWhereUniqueInput[]
    | CustomerRelationshipWhereUniqueInput
  >;
}

export interface CustomerRelationshipCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ValuePropositionCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | ValuePropositionCreateWithoutTable_idsInput[]
    | ValuePropositionCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
}

export interface ValuePropositionCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CostStructureCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | CostStructureCreateWithoutTable_idsInput[]
    | CostStructureCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    CostStructureWhereUniqueInput[] | CostStructureWhereUniqueInput
  >;
}

export interface CostStructureCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CustomerSegmentCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | CustomerSegmentCreateWithoutTable_idsInput[]
    | CustomerSegmentCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    CustomerSegmentWhereUniqueInput[] | CustomerSegmentWhereUniqueInput
  >;
}

export interface CustomerSegmentCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface KeyResourceCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | KeyResourceCreateWithoutTable_idsInput[]
    | KeyResourceCreateWithoutTable_idsInput
  >;
  connect?: Maybe<KeyResourceWhereUniqueInput[] | KeyResourceWhereUniqueInput>;
}

export interface KeyResourceCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ChannelCreateManyWithoutTable_idsInput {
  create?: Maybe<
    ChannelCreateWithoutTable_idsInput[] | ChannelCreateWithoutTable_idsInput
  >;
  connect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
}

export interface ChannelCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CompanyCreateManyWithoutPattern_idsInput {
  create?: Maybe<
    | CompanyCreateWithoutPattern_idsInput[]
    | CompanyCreateWithoutPattern_idsInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutPattern_idsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
}

export interface CanvasUpdateInput {
  project_id?: Maybe<ProjectUpdateOneRequiredWithoutCanvas_idsInput>;
  pattern_ids?: Maybe<PatternUpdateManyWithoutCanvas_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ProjectUpdateOneRequiredWithoutCanvas_idsInput {
  create?: Maybe<ProjectCreateWithoutCanvas_idsInput>;
  update?: Maybe<ProjectUpdateWithoutCanvas_idsDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutCanvas_idsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface ProjectUpdateWithoutCanvas_idsDataInput {
  user_id?: Maybe<UserUpdateOneRequiredWithoutProject_idsInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredWithoutProject_idsInput {
  create?: Maybe<UserCreateWithoutProject_idsInput>;
  update?: Maybe<UserUpdateWithoutProject_idsDataInput>;
  upsert?: Maybe<UserUpsertWithoutProject_idsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutProject_idsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserUpdateOneWithoutUpdatedByInput>;
}

export interface UserUpdateOneWithoutUpdatedByInput {
  create?: Maybe<UserCreateWithoutUpdatedByInput>;
  update?: Maybe<UserUpdateWithoutUpdatedByDataInput>;
  upsert?: Maybe<UserUpsertWithoutUpdatedByInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutUpdatedByDataInput {
  project_ids?: Maybe<ProjectUpdateManyWithoutUser_idInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
}

export interface ProjectUpdateManyWithoutUser_idInput {
  create?: Maybe<
    ProjectCreateWithoutUser_idInput[] | ProjectCreateWithoutUser_idInput
  >;
  delete?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  set?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  disconnect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  update?: Maybe<
    | ProjectUpdateWithWhereUniqueWithoutUser_idInput[]
    | ProjectUpdateWithWhereUniqueWithoutUser_idInput
  >;
  upsert?: Maybe<
    | ProjectUpsertWithWhereUniqueWithoutUser_idInput[]
    | ProjectUpsertWithWhereUniqueWithoutUser_idInput
  >;
  deleteMany?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  updateMany?: Maybe<
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectUpdateWithWhereUniqueWithoutUser_idInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutUser_idDataInput;
}

export interface ProjectUpdateWithoutUser_idDataInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutProject_idInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CanvasUpdateManyWithoutProject_idInput {
  create?: Maybe<
    CanvasCreateWithoutProject_idInput[] | CanvasCreateWithoutProject_idInput
  >;
  delete?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  set?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  disconnect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  update?: Maybe<
    | CanvasUpdateWithWhereUniqueWithoutProject_idInput[]
    | CanvasUpdateWithWhereUniqueWithoutProject_idInput
  >;
  upsert?: Maybe<
    | CanvasUpsertWithWhereUniqueWithoutProject_idInput[]
    | CanvasUpsertWithWhereUniqueWithoutProject_idInput
  >;
  deleteMany?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  updateMany?: Maybe<
    | CanvasUpdateManyWithWhereNestedInput[]
    | CanvasUpdateManyWithWhereNestedInput
  >;
}

export interface CanvasUpdateWithWhereUniqueWithoutProject_idInput {
  where: CanvasWhereUniqueInput;
  data: CanvasUpdateWithoutProject_idDataInput;
}

export interface CanvasUpdateWithoutProject_idDataInput {
  pattern_ids?: Maybe<PatternUpdateManyWithoutCanvas_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface PatternUpdateManyWithoutCanvas_idsInput {
  create?: Maybe<
    PatternCreateWithoutCanvas_idsInput[] | PatternCreateWithoutCanvas_idsInput
  >;
  delete?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  connect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  set?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  disconnect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  update?: Maybe<
    | PatternUpdateWithWhereUniqueWithoutCanvas_idsInput[]
    | PatternUpdateWithWhereUniqueWithoutCanvas_idsInput
  >;
  upsert?: Maybe<
    | PatternUpsertWithWhereUniqueWithoutCanvas_idsInput[]
    | PatternUpsertWithWhereUniqueWithoutCanvas_idsInput
  >;
  deleteMany?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
  updateMany?: Maybe<
    | PatternUpdateManyWithWhereNestedInput[]
    | PatternUpdateManyWithWhereNestedInput
  >;
}

export interface PatternUpdateWithWhereUniqueWithoutCanvas_idsInput {
  where: PatternWhereUniqueInput;
  data: PatternUpdateWithoutCanvas_idsDataInput;
}

export interface PatternUpdateWithoutCanvas_idsDataInput {
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  company_ids?: Maybe<CompanyUpdateManyWithoutPattern_idsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateOneRequiredInput {
  create?: Maybe<TableCreateInput>;
  update?: Maybe<TableUpdateDataInput>;
  upsert?: Maybe<TableUpsertNestedInput>;
  connect?: Maybe<TableWhereUniqueInput>;
}

export interface TableUpdateDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface KeyPartnerUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | KeyPartnerCreateWithoutTable_idsInput[]
    | KeyPartnerCreateWithoutTable_idsInput
  >;
  delete?: Maybe<KeyPartnerWhereUniqueInput[] | KeyPartnerWhereUniqueInput>;
  connect?: Maybe<KeyPartnerWhereUniqueInput[] | KeyPartnerWhereUniqueInput>;
  set?: Maybe<KeyPartnerWhereUniqueInput[] | KeyPartnerWhereUniqueInput>;
  disconnect?: Maybe<KeyPartnerWhereUniqueInput[] | KeyPartnerWhereUniqueInput>;
  update?: Maybe<
    | KeyPartnerUpdateWithWhereUniqueWithoutTable_idsInput[]
    | KeyPartnerUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | KeyPartnerUpsertWithWhereUniqueWithoutTable_idsInput[]
    | KeyPartnerUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<KeyPartnerScalarWhereInput[] | KeyPartnerScalarWhereInput>;
  updateMany?: Maybe<
    | KeyPartnerUpdateManyWithWhereNestedInput[]
    | KeyPartnerUpdateManyWithWhereNestedInput
  >;
}

export interface KeyPartnerUpdateWithWhereUniqueWithoutTable_idsInput {
  where: KeyPartnerWhereUniqueInput;
  data: KeyPartnerUpdateWithoutTable_idsDataInput;
}

export interface KeyPartnerUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  project_ids?: Maybe<ProjectUpdateManyWithoutUser_idInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserUpdateOneWithoutUpdatedByInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface KeyPartnerUpsertWithWhereUniqueWithoutTable_idsInput {
  where: KeyPartnerWhereUniqueInput;
  update: KeyPartnerUpdateWithoutTable_idsDataInput;
  create: KeyPartnerCreateWithoutTable_idsInput;
}

export interface KeyPartnerScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<KeyPartnerScalarWhereInput[] | KeyPartnerScalarWhereInput>;
  OR?: Maybe<KeyPartnerScalarWhereInput[] | KeyPartnerScalarWhereInput>;
  NOT?: Maybe<KeyPartnerScalarWhereInput[] | KeyPartnerScalarWhereInput>;
}

export interface KeyPartnerUpdateManyWithWhereNestedInput {
  where: KeyPartnerScalarWhereInput;
  data: KeyPartnerUpdateManyDataInput;
}

export interface KeyPartnerUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface RevenueStreamUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | RevenueStreamCreateWithoutTable_idsInput[]
    | RevenueStreamCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    RevenueStreamWhereUniqueInput[] | RevenueStreamWhereUniqueInput
  >;
  connect?: Maybe<
    RevenueStreamWhereUniqueInput[] | RevenueStreamWhereUniqueInput
  >;
  set?: Maybe<RevenueStreamWhereUniqueInput[] | RevenueStreamWhereUniqueInput>;
  disconnect?: Maybe<
    RevenueStreamWhereUniqueInput[] | RevenueStreamWhereUniqueInput
  >;
  update?: Maybe<
    | RevenueStreamUpdateWithWhereUniqueWithoutTable_idsInput[]
    | RevenueStreamUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | RevenueStreamUpsertWithWhereUniqueWithoutTable_idsInput[]
    | RevenueStreamUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    RevenueStreamScalarWhereInput[] | RevenueStreamScalarWhereInput
  >;
  updateMany?: Maybe<
    | RevenueStreamUpdateManyWithWhereNestedInput[]
    | RevenueStreamUpdateManyWithWhereNestedInput
  >;
}

export interface RevenueStreamUpdateWithWhereUniqueWithoutTable_idsInput {
  where: RevenueStreamWhereUniqueInput;
  data: RevenueStreamUpdateWithoutTable_idsDataInput;
}

export interface RevenueStreamUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface RevenueStreamUpsertWithWhereUniqueWithoutTable_idsInput {
  where: RevenueStreamWhereUniqueInput;
  update: RevenueStreamUpdateWithoutTable_idsDataInput;
  create: RevenueStreamCreateWithoutTable_idsInput;
}

export interface RevenueStreamScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RevenueStreamScalarWhereInput[] | RevenueStreamScalarWhereInput>;
  OR?: Maybe<RevenueStreamScalarWhereInput[] | RevenueStreamScalarWhereInput>;
  NOT?: Maybe<RevenueStreamScalarWhereInput[] | RevenueStreamScalarWhereInput>;
}

export interface RevenueStreamUpdateManyWithWhereNestedInput {
  where: RevenueStreamScalarWhereInput;
  data: RevenueStreamUpdateManyDataInput;
}

export interface RevenueStreamUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface KeyActitvityUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | KeyActitvityCreateWithoutTable_idsInput[]
    | KeyActitvityCreateWithoutTable_idsInput
  >;
  delete?: Maybe<KeyActitvityWhereUniqueInput[] | KeyActitvityWhereUniqueInput>;
  connect?: Maybe<
    KeyActitvityWhereUniqueInput[] | KeyActitvityWhereUniqueInput
  >;
  set?: Maybe<KeyActitvityWhereUniqueInput[] | KeyActitvityWhereUniqueInput>;
  disconnect?: Maybe<
    KeyActitvityWhereUniqueInput[] | KeyActitvityWhereUniqueInput
  >;
  update?: Maybe<
    | KeyActitvityUpdateWithWhereUniqueWithoutTable_idsInput[]
    | KeyActitvityUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | KeyActitvityUpsertWithWhereUniqueWithoutTable_idsInput[]
    | KeyActitvityUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    KeyActitvityScalarWhereInput[] | KeyActitvityScalarWhereInput
  >;
  updateMany?: Maybe<
    | KeyActitvityUpdateManyWithWhereNestedInput[]
    | KeyActitvityUpdateManyWithWhereNestedInput
  >;
}

export interface KeyActitvityUpdateWithWhereUniqueWithoutTable_idsInput {
  where: KeyActitvityWhereUniqueInput;
  data: KeyActitvityUpdateWithoutTable_idsDataInput;
}

export interface KeyActitvityUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface KeyActitvityUpsertWithWhereUniqueWithoutTable_idsInput {
  where: KeyActitvityWhereUniqueInput;
  update: KeyActitvityUpdateWithoutTable_idsDataInput;
  create: KeyActitvityCreateWithoutTable_idsInput;
}

export interface KeyActitvityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<KeyActitvityScalarWhereInput[] | KeyActitvityScalarWhereInput>;
  OR?: Maybe<KeyActitvityScalarWhereInput[] | KeyActitvityScalarWhereInput>;
  NOT?: Maybe<KeyActitvityScalarWhereInput[] | KeyActitvityScalarWhereInput>;
}

export interface KeyActitvityUpdateManyWithWhereNestedInput {
  where: KeyActitvityScalarWhereInput;
  data: KeyActitvityUpdateManyDataInput;
}

export interface KeyActitvityUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface CustomerRelationshipUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | CustomerRelationshipCreateWithoutTable_idsInput[]
    | CustomerRelationshipCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    | CustomerRelationshipWhereUniqueInput[]
    | CustomerRelationshipWhereUniqueInput
  >;
  connect?: Maybe<
    | CustomerRelationshipWhereUniqueInput[]
    | CustomerRelationshipWhereUniqueInput
  >;
  set?: Maybe<
    | CustomerRelationshipWhereUniqueInput[]
    | CustomerRelationshipWhereUniqueInput
  >;
  disconnect?: Maybe<
    | CustomerRelationshipWhereUniqueInput[]
    | CustomerRelationshipWhereUniqueInput
  >;
  update?: Maybe<
    | CustomerRelationshipUpdateWithWhereUniqueWithoutTable_idsInput[]
    | CustomerRelationshipUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | CustomerRelationshipUpsertWithWhereUniqueWithoutTable_idsInput[]
    | CustomerRelationshipUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    | CustomerRelationshipScalarWhereInput[]
    | CustomerRelationshipScalarWhereInput
  >;
  updateMany?: Maybe<
    | CustomerRelationshipUpdateManyWithWhereNestedInput[]
    | CustomerRelationshipUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerRelationshipUpdateWithWhereUniqueWithoutTable_idsInput {
  where: CustomerRelationshipWhereUniqueInput;
  data: CustomerRelationshipUpdateWithoutTable_idsDataInput;
}

export interface CustomerRelationshipUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CustomerRelationshipUpsertWithWhereUniqueWithoutTable_idsInput {
  where: CustomerRelationshipWhereUniqueInput;
  update: CustomerRelationshipUpdateWithoutTable_idsDataInput;
  create: CustomerRelationshipCreateWithoutTable_idsInput;
}

export interface CustomerRelationshipScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | CustomerRelationshipScalarWhereInput[]
    | CustomerRelationshipScalarWhereInput
  >;
  OR?: Maybe<
    | CustomerRelationshipScalarWhereInput[]
    | CustomerRelationshipScalarWhereInput
  >;
  NOT?: Maybe<
    | CustomerRelationshipScalarWhereInput[]
    | CustomerRelationshipScalarWhereInput
  >;
}

export interface CustomerRelationshipUpdateManyWithWhereNestedInput {
  where: CustomerRelationshipScalarWhereInput;
  data: CustomerRelationshipUpdateManyDataInput;
}

export interface CustomerRelationshipUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface ValuePropositionUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | ValuePropositionCreateWithoutTable_idsInput[]
    | ValuePropositionCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
  connect?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
  set?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
  disconnect?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
  update?: Maybe<
    | ValuePropositionUpdateWithWhereUniqueWithoutTable_idsInput[]
    | ValuePropositionUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | ValuePropositionUpsertWithWhereUniqueWithoutTable_idsInput[]
    | ValuePropositionUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    ValuePropositionScalarWhereInput[] | ValuePropositionScalarWhereInput
  >;
  updateMany?: Maybe<
    | ValuePropositionUpdateManyWithWhereNestedInput[]
    | ValuePropositionUpdateManyWithWhereNestedInput
  >;
}

export interface ValuePropositionUpdateWithWhereUniqueWithoutTable_idsInput {
  where: ValuePropositionWhereUniqueInput;
  data: ValuePropositionUpdateWithoutTable_idsDataInput;
}

export interface ValuePropositionUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ValuePropositionUpsertWithWhereUniqueWithoutTable_idsInput {
  where: ValuePropositionWhereUniqueInput;
  update: ValuePropositionUpdateWithoutTable_idsDataInput;
  create: ValuePropositionCreateWithoutTable_idsInput;
}

export interface ValuePropositionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ValuePropositionScalarWhereInput[] | ValuePropositionScalarWhereInput
  >;
  OR?: Maybe<
    ValuePropositionScalarWhereInput[] | ValuePropositionScalarWhereInput
  >;
  NOT?: Maybe<
    ValuePropositionScalarWhereInput[] | ValuePropositionScalarWhereInput
  >;
}

export interface ValuePropositionUpdateManyWithWhereNestedInput {
  where: ValuePropositionScalarWhereInput;
  data: ValuePropositionUpdateManyDataInput;
}

export interface ValuePropositionUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface CostStructureUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | CostStructureCreateWithoutTable_idsInput[]
    | CostStructureCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    CostStructureWhereUniqueInput[] | CostStructureWhereUniqueInput
  >;
  connect?: Maybe<
    CostStructureWhereUniqueInput[] | CostStructureWhereUniqueInput
  >;
  set?: Maybe<CostStructureWhereUniqueInput[] | CostStructureWhereUniqueInput>;
  disconnect?: Maybe<
    CostStructureWhereUniqueInput[] | CostStructureWhereUniqueInput
  >;
  update?: Maybe<
    | CostStructureUpdateWithWhereUniqueWithoutTable_idsInput[]
    | CostStructureUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | CostStructureUpsertWithWhereUniqueWithoutTable_idsInput[]
    | CostStructureUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    CostStructureScalarWhereInput[] | CostStructureScalarWhereInput
  >;
  updateMany?: Maybe<
    | CostStructureUpdateManyWithWhereNestedInput[]
    | CostStructureUpdateManyWithWhereNestedInput
  >;
}

export interface CostStructureUpdateWithWhereUniqueWithoutTable_idsInput {
  where: CostStructureWhereUniqueInput;
  data: CostStructureUpdateWithoutTable_idsDataInput;
}

export interface CostStructureUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CostStructureUpsertWithWhereUniqueWithoutTable_idsInput {
  where: CostStructureWhereUniqueInput;
  update: CostStructureUpdateWithoutTable_idsDataInput;
  create: CostStructureCreateWithoutTable_idsInput;
}

export interface CostStructureScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CostStructureScalarWhereInput[] | CostStructureScalarWhereInput>;
  OR?: Maybe<CostStructureScalarWhereInput[] | CostStructureScalarWhereInput>;
  NOT?: Maybe<CostStructureScalarWhereInput[] | CostStructureScalarWhereInput>;
}

export interface CostStructureUpdateManyWithWhereNestedInput {
  where: CostStructureScalarWhereInput;
  data: CostStructureUpdateManyDataInput;
}

export interface CostStructureUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface CustomerSegmentUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | CustomerSegmentCreateWithoutTable_idsInput[]
    | CustomerSegmentCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    CustomerSegmentWhereUniqueInput[] | CustomerSegmentWhereUniqueInput
  >;
  connect?: Maybe<
    CustomerSegmentWhereUniqueInput[] | CustomerSegmentWhereUniqueInput
  >;
  set?: Maybe<
    CustomerSegmentWhereUniqueInput[] | CustomerSegmentWhereUniqueInput
  >;
  disconnect?: Maybe<
    CustomerSegmentWhereUniqueInput[] | CustomerSegmentWhereUniqueInput
  >;
  update?: Maybe<
    | CustomerSegmentUpdateWithWhereUniqueWithoutTable_idsInput[]
    | CustomerSegmentUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | CustomerSegmentUpsertWithWhereUniqueWithoutTable_idsInput[]
    | CustomerSegmentUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    CustomerSegmentScalarWhereInput[] | CustomerSegmentScalarWhereInput
  >;
  updateMany?: Maybe<
    | CustomerSegmentUpdateManyWithWhereNestedInput[]
    | CustomerSegmentUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerSegmentUpdateWithWhereUniqueWithoutTable_idsInput {
  where: CustomerSegmentWhereUniqueInput;
  data: CustomerSegmentUpdateWithoutTable_idsDataInput;
}

export interface CustomerSegmentUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CustomerSegmentUpsertWithWhereUniqueWithoutTable_idsInput {
  where: CustomerSegmentWhereUniqueInput;
  update: CustomerSegmentUpdateWithoutTable_idsDataInput;
  create: CustomerSegmentCreateWithoutTable_idsInput;
}

export interface CustomerSegmentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CustomerSegmentScalarWhereInput[] | CustomerSegmentScalarWhereInput
  >;
  OR?: Maybe<
    CustomerSegmentScalarWhereInput[] | CustomerSegmentScalarWhereInput
  >;
  NOT?: Maybe<
    CustomerSegmentScalarWhereInput[] | CustomerSegmentScalarWhereInput
  >;
}

export interface CustomerSegmentUpdateManyWithWhereNestedInput {
  where: CustomerSegmentScalarWhereInput;
  data: CustomerSegmentUpdateManyDataInput;
}

export interface CustomerSegmentUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface KeyResourceUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | KeyResourceCreateWithoutTable_idsInput[]
    | KeyResourceCreateWithoutTable_idsInput
  >;
  delete?: Maybe<KeyResourceWhereUniqueInput[] | KeyResourceWhereUniqueInput>;
  connect?: Maybe<KeyResourceWhereUniqueInput[] | KeyResourceWhereUniqueInput>;
  set?: Maybe<KeyResourceWhereUniqueInput[] | KeyResourceWhereUniqueInput>;
  disconnect?: Maybe<
    KeyResourceWhereUniqueInput[] | KeyResourceWhereUniqueInput
  >;
  update?: Maybe<
    | KeyResourceUpdateWithWhereUniqueWithoutTable_idsInput[]
    | KeyResourceUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | KeyResourceUpsertWithWhereUniqueWithoutTable_idsInput[]
    | KeyResourceUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    KeyResourceScalarWhereInput[] | KeyResourceScalarWhereInput
  >;
  updateMany?: Maybe<
    | KeyResourceUpdateManyWithWhereNestedInput[]
    | KeyResourceUpdateManyWithWhereNestedInput
  >;
}

export interface KeyResourceUpdateWithWhereUniqueWithoutTable_idsInput {
  where: KeyResourceWhereUniqueInput;
  data: KeyResourceUpdateWithoutTable_idsDataInput;
}

export interface KeyResourceUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface KeyResourceUpsertWithWhereUniqueWithoutTable_idsInput {
  where: KeyResourceWhereUniqueInput;
  update: KeyResourceUpdateWithoutTable_idsDataInput;
  create: KeyResourceCreateWithoutTable_idsInput;
}

export interface KeyResourceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<KeyResourceScalarWhereInput[] | KeyResourceScalarWhereInput>;
  OR?: Maybe<KeyResourceScalarWhereInput[] | KeyResourceScalarWhereInput>;
  NOT?: Maybe<KeyResourceScalarWhereInput[] | KeyResourceScalarWhereInput>;
}

export interface KeyResourceUpdateManyWithWhereNestedInput {
  where: KeyResourceScalarWhereInput;
  data: KeyResourceUpdateManyDataInput;
}

export interface KeyResourceUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface ChannelUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    ChannelCreateWithoutTable_idsInput[] | ChannelCreateWithoutTable_idsInput
  >;
  delete?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  connect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  set?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  disconnect?: Maybe<ChannelWhereUniqueInput[] | ChannelWhereUniqueInput>;
  update?: Maybe<
    | ChannelUpdateWithWhereUniqueWithoutTable_idsInput[]
    | ChannelUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | ChannelUpsertWithWhereUniqueWithoutTable_idsInput[]
    | ChannelUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
  updateMany?: Maybe<
    | ChannelUpdateManyWithWhereNestedInput[]
    | ChannelUpdateManyWithWhereNestedInput
  >;
}

export interface ChannelUpdateWithWhereUniqueWithoutTable_idsInput {
  where: ChannelWhereUniqueInput;
  data: ChannelUpdateWithoutTable_idsDataInput;
}

export interface ChannelUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ChannelUpsertWithWhereUniqueWithoutTable_idsInput {
  where: ChannelWhereUniqueInput;
  update: ChannelUpdateWithoutTable_idsDataInput;
  create: ChannelCreateWithoutTable_idsInput;
}

export interface ChannelScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
  OR?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
  NOT?: Maybe<ChannelScalarWhereInput[] | ChannelScalarWhereInput>;
}

export interface ChannelUpdateManyWithWhereNestedInput {
  where: ChannelScalarWhereInput;
  data: ChannelUpdateManyDataInput;
}

export interface ChannelUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface TableUpsertNestedInput {
  update: TableUpdateDataInput;
  create: TableCreateInput;
}

export interface CompanyUpdateManyWithoutPattern_idsInput {
  create?: Maybe<
    | CompanyCreateWithoutPattern_idsInput[]
    | CompanyCreateWithoutPattern_idsInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutPattern_idsInput[]
    | CompanyUpdateWithWhereUniqueWithoutPattern_idsInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutPattern_idsInput[]
    | CompanyUpsertWithWhereUniqueWithoutPattern_idsInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutPattern_idsInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutPattern_idsDataInput;
}

export interface CompanyUpdateWithoutPattern_idsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CompanyUpsertWithWhereUniqueWithoutPattern_idsInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutPattern_idsDataInput;
  create: CompanyCreateWithoutPattern_idsInput;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface CompanyUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface PatternUpsertWithWhereUniqueWithoutCanvas_idsInput {
  where: PatternWhereUniqueInput;
  update: PatternUpdateWithoutCanvas_idsDataInput;
  create: PatternCreateWithoutCanvas_idsInput;
}

export interface PatternScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
  OR?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
  NOT?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
}

export interface PatternUpdateManyWithWhereNestedInput {
  where: PatternScalarWhereInput;
  data: PatternUpdateManyDataInput;
}

export interface PatternUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CanvasUpsertWithWhereUniqueWithoutProject_idInput {
  where: CanvasWhereUniqueInput;
  update: CanvasUpdateWithoutProject_idDataInput;
  create: CanvasCreateWithoutProject_idInput;
}

export interface CanvasScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  OR?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  NOT?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
}

export interface CanvasUpdateManyWithWhereNestedInput {
  where: CanvasScalarWhereInput;
  data: CanvasUpdateManyDataInput;
}

export interface CanvasUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ProjectUpsertWithWhereUniqueWithoutUser_idInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutUser_idDataInput;
  create: ProjectCreateWithoutUser_idInput;
}

export interface ProjectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  OR?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  NOT?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface ProjectUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserUpsertWithoutUpdatedByInput {
  update: UserUpdateWithoutUpdatedByDataInput;
  create: UserCreateWithoutUpdatedByInput;
}

export interface UserUpsertWithoutProject_idsInput {
  update: UserUpdateWithoutProject_idsDataInput;
  create: UserCreateWithoutProject_idsInput;
}

export interface ProjectUpsertWithoutCanvas_idsInput {
  update: ProjectUpdateWithoutCanvas_idsDataInput;
  create: ProjectCreateWithoutCanvas_idsInput;
}

export interface CanvasUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ChannelCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutChannel_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutChannel_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutChannel_entry_idsInput[]
    | TableCreateWithoutChannel_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutChannel_entry_idsInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
}

export interface ChannelUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutChannel_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutChannel_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutChannel_entry_idsInput[]
    | TableCreateWithoutChannel_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutChannel_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutChannel_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutChannel_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutChannel_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutChannel_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutChannel_entry_idsDataInput;
}

export interface TableUpdateWithoutChannel_entry_idsDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutChannel_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutChannel_entry_idsDataInput;
  create: TableCreateWithoutChannel_entry_idsInput;
}

export interface TableScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
  OR?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
  NOT?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface ChannelUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  pattern_ids?: Maybe<PatternCreateManyWithoutCompany_idsInput>;
  name: String;
  description?: Maybe<String>;
}

export interface PatternCreateManyWithoutCompany_idsInput {
  create?: Maybe<
    | PatternCreateWithoutCompany_idsInput[]
    | PatternCreateWithoutCompany_idsInput
  >;
  connect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
}

export interface PatternCreateWithoutCompany_idsInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutPattern_idsInput>;
  table_id: TableCreateOneInput;
  name: String;
  description?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CanvasCreateManyWithoutPattern_idsInput {
  create?: Maybe<
    CanvasCreateWithoutPattern_idsInput[] | CanvasCreateWithoutPattern_idsInput
  >;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
}

export interface CanvasCreateWithoutPattern_idsInput {
  id?: Maybe<ID_Input>;
  project_id: ProjectCreateOneWithoutCanvas_idsInput;
  table_id: TableCreateOneInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CompanyUpdateInput {
  pattern_ids?: Maybe<PatternUpdateManyWithoutCompany_idsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface PatternUpdateManyWithoutCompany_idsInput {
  create?: Maybe<
    | PatternCreateWithoutCompany_idsInput[]
    | PatternCreateWithoutCompany_idsInput
  >;
  delete?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  connect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  set?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  disconnect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  update?: Maybe<
    | PatternUpdateWithWhereUniqueWithoutCompany_idsInput[]
    | PatternUpdateWithWhereUniqueWithoutCompany_idsInput
  >;
  upsert?: Maybe<
    | PatternUpsertWithWhereUniqueWithoutCompany_idsInput[]
    | PatternUpsertWithWhereUniqueWithoutCompany_idsInput
  >;
  deleteMany?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
  updateMany?: Maybe<
    | PatternUpdateManyWithWhereNestedInput[]
    | PatternUpdateManyWithWhereNestedInput
  >;
}

export interface PatternUpdateWithWhereUniqueWithoutCompany_idsInput {
  where: PatternWhereUniqueInput;
  data: PatternUpdateWithoutCompany_idsDataInput;
}

export interface PatternUpdateWithoutCompany_idsDataInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutPattern_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CanvasUpdateManyWithoutPattern_idsInput {
  create?: Maybe<
    CanvasCreateWithoutPattern_idsInput[] | CanvasCreateWithoutPattern_idsInput
  >;
  delete?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  set?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  disconnect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  update?: Maybe<
    | CanvasUpdateWithWhereUniqueWithoutPattern_idsInput[]
    | CanvasUpdateWithWhereUniqueWithoutPattern_idsInput
  >;
  upsert?: Maybe<
    | CanvasUpsertWithWhereUniqueWithoutPattern_idsInput[]
    | CanvasUpsertWithWhereUniqueWithoutPattern_idsInput
  >;
  deleteMany?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  updateMany?: Maybe<
    | CanvasUpdateManyWithWhereNestedInput[]
    | CanvasUpdateManyWithWhereNestedInput
  >;
}

export interface CanvasUpdateWithWhereUniqueWithoutPattern_idsInput {
  where: CanvasWhereUniqueInput;
  data: CanvasUpdateWithoutPattern_idsDataInput;
}

export interface CanvasUpdateWithoutPattern_idsDataInput {
  project_id?: Maybe<ProjectUpdateOneRequiredWithoutCanvas_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CanvasUpsertWithWhereUniqueWithoutPattern_idsInput {
  where: CanvasWhereUniqueInput;
  update: CanvasUpdateWithoutPattern_idsDataInput;
  create: CanvasCreateWithoutPattern_idsInput;
}

export interface PatternUpsertWithWhereUniqueWithoutCompany_idsInput {
  where: PatternWhereUniqueInput;
  update: PatternUpdateWithoutCompany_idsDataInput;
  create: PatternCreateWithoutCompany_idsInput;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CostStructureCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutCost_structure_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutCost_structure_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutCost_structure_entry_idsInput[]
    | TableCreateWithoutCost_structure_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutCost_structure_entry_idsInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface CostStructureUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutCost_structure_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutCost_structure_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutCost_structure_entry_idsInput[]
    | TableCreateWithoutCost_structure_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutCost_structure_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutCost_structure_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutCost_structure_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutCost_structure_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutCost_structure_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutCost_structure_entry_idsDataInput;
}

export interface TableUpdateWithoutCost_structure_entry_idsDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutCost_structure_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutCost_structure_entry_idsDataInput;
  create: TableCreateWithoutCost_structure_entry_idsInput;
}

export interface CostStructureUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface CustomerRelationshipCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutCustomer_relationship_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutCustomer_relationship_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutCustomer_relationship_entry_idsInput[]
    | TableCreateWithoutCustomer_relationship_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutCustomer_relationship_entry_idsInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface CustomerRelationshipUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutCustomer_relationship_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutCustomer_relationship_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutCustomer_relationship_entry_idsInput[]
    | TableCreateWithoutCustomer_relationship_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutCustomer_relationship_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutCustomer_relationship_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutCustomer_relationship_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutCustomer_relationship_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutCustomer_relationship_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutCustomer_relationship_entry_idsDataInput;
}

export interface TableUpdateWithoutCustomer_relationship_entry_idsDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutCustomer_relationship_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutCustomer_relationship_entry_idsDataInput;
  create: TableCreateWithoutCustomer_relationship_entry_idsInput;
}

export interface CustomerRelationshipUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface CustomerSegmentCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutCustomer_segment_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutCustomer_segment_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutCustomer_segment_entry_idsInput[]
    | TableCreateWithoutCustomer_segment_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutCustomer_segment_entry_idsInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface CustomerSegmentUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutCustomer_segment_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutCustomer_segment_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutCustomer_segment_entry_idsInput[]
    | TableCreateWithoutCustomer_segment_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutCustomer_segment_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutCustomer_segment_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutCustomer_segment_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutCustomer_segment_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutCustomer_segment_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutCustomer_segment_entry_idsDataInput;
}

export interface TableUpdateWithoutCustomer_segment_entry_idsDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutCustomer_segment_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutCustomer_segment_entry_idsDataInput;
  create: TableCreateWithoutCustomer_segment_entry_idsInput;
}

export interface CustomerSegmentUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface KeyActitvityCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutKey_activity_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutKey_activity_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutKey_activity_entry_idsInput[]
    | TableCreateWithoutKey_activity_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutKey_activity_entry_idsInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface KeyActitvityUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutKey_activity_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutKey_activity_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutKey_activity_entry_idsInput[]
    | TableCreateWithoutKey_activity_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutKey_activity_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutKey_activity_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutKey_activity_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutKey_activity_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutKey_activity_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutKey_activity_entry_idsDataInput;
}

export interface TableUpdateWithoutKey_activity_entry_idsDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutKey_activity_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutKey_activity_entry_idsDataInput;
  create: TableCreateWithoutKey_activity_entry_idsInput;
}

export interface KeyActitvityUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface KeyPartnerCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutKey_partner_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutKey_partner_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutKey_partner_entry_idsInput[]
    | TableCreateWithoutKey_partner_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutKey_partner_entry_idsInput {
  id?: Maybe<ID_Input>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface KeyPartnerUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutKey_partner_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutKey_partner_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutKey_partner_entry_idsInput[]
    | TableCreateWithoutKey_partner_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutKey_partner_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutKey_partner_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutKey_partner_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutKey_partner_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutKey_partner_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutKey_partner_entry_idsDataInput;
}

export interface TableUpdateWithoutKey_partner_entry_idsDataInput {
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutKey_partner_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutKey_partner_entry_idsDataInput;
  create: TableCreateWithoutKey_partner_entry_idsInput;
}

export interface KeyPartnerUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface KeyResourceCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutKey_resource_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutKey_resource_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutKey_resource_entry_idsInput[]
    | TableCreateWithoutKey_resource_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutKey_resource_entry_idsInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface KeyResourceUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutKey_resource_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutKey_resource_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutKey_resource_entry_idsInput[]
    | TableCreateWithoutKey_resource_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutKey_resource_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutKey_resource_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutKey_resource_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutKey_resource_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutKey_resource_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutKey_resource_entry_idsDataInput;
}

export interface TableUpdateWithoutKey_resource_entry_idsDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutKey_resource_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutKey_resource_entry_idsDataInput;
  create: TableCreateWithoutKey_resource_entry_idsInput;
}

export interface KeyResourceUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface PatternCreateInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutPattern_idsInput>;
  table_id: TableCreateOneInput;
  company_ids?: Maybe<CompanyCreateManyWithoutPattern_idsInput>;
  name: String;
  description?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface PatternUpdateInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutPattern_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  company_ids?: Maybe<CompanyUpdateManyWithoutPattern_idsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface PatternUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ProjectCreateInput {
  id?: Maybe<ID_Input>;
  user_id: UserCreateOneWithoutProject_idsInput;
  canvas_ids?: Maybe<CanvasCreateManyWithoutProject_idInput>;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ProjectUpdateInput {
  user_id?: Maybe<UserUpdateOneRequiredWithoutProject_idsInput>;
  canvas_ids?: Maybe<CanvasUpdateManyWithoutProject_idInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ProjectUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface RevenueStreamCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutReventue_stream_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutReventue_stream_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutReventue_stream_entry_idsInput[]
    | TableCreateWithoutReventue_stream_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutReventue_stream_entry_idsInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface RevenueStreamUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutReventue_stream_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutReventue_stream_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutReventue_stream_entry_idsInput[]
    | TableCreateWithoutReventue_stream_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutReventue_stream_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutReventue_stream_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutReventue_stream_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutReventue_stream_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutReventue_stream_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutReventue_stream_entry_idsDataInput;
}

export interface TableUpdateWithoutReventue_stream_entry_idsDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutReventue_stream_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutReventue_stream_entry_idsDataInput;
  create: TableCreateWithoutReventue_stream_entry_idsInput;
}

export interface RevenueStreamUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface TableUpdateInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface UserUpdateInput {
  project_ids?: Maybe<ProjectUpdateManyWithoutUser_idInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserUpdateOneWithoutUpdatedByInput>;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
}

export interface ValuePropositionCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutValue_proposition_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutValue_proposition_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutValue_proposition_entry_idsInput[]
    | TableCreateWithoutValue_proposition_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutValue_proposition_entry_idsInput {
  id?: Maybe<ID_Input>;
  key_partner_entry_ids?: Maybe<KeyPartnerCreateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamCreateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityCreateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipCreateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureCreateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentCreateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceCreateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelCreateManyWithoutTable_idsInput>;
}

export interface ValuePropositionUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutValue_proposition_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutValue_proposition_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutValue_proposition_entry_idsInput[]
    | TableCreateWithoutValue_proposition_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutValue_proposition_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutValue_proposition_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutValue_proposition_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutValue_proposition_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutValue_proposition_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutValue_proposition_entry_idsDataInput;
}

export interface TableUpdateWithoutValue_proposition_entry_idsDataInput {
  key_partner_entry_ids?: Maybe<KeyPartnerUpdateManyWithoutTable_idsInput>;
  reventue_stream_entry_ids?: Maybe<
    RevenueStreamUpdateManyWithoutTable_idsInput
  >;
  key_activity_entry_ids?: Maybe<KeyActitvityUpdateManyWithoutTable_idsInput>;
  customer_relationship_entry_ids?: Maybe<
    CustomerRelationshipUpdateManyWithoutTable_idsInput
  >;
  cost_structure_entry_ids?: Maybe<
    CostStructureUpdateManyWithoutTable_idsInput
  >;
  customer_segment_entry_ids?: Maybe<
    CustomerSegmentUpdateManyWithoutTable_idsInput
  >;
  key_resource_entry_ids?: Maybe<KeyResourceUpdateManyWithoutTable_idsInput>;
  channel_entry_ids?: Maybe<ChannelUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutValue_proposition_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutValue_proposition_entry_idsDataInput;
  create: TableCreateWithoutValue_proposition_entry_idsInput;
}

export interface ValuePropositionUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface CanvasSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CanvasWhereInput>;
  AND?: Maybe<CanvasSubscriptionWhereInput[] | CanvasSubscriptionWhereInput>;
  OR?: Maybe<CanvasSubscriptionWhereInput[] | CanvasSubscriptionWhereInput>;
  NOT?: Maybe<CanvasSubscriptionWhereInput[] | CanvasSubscriptionWhereInput>;
}

export interface ChannelSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChannelWhereInput>;
  AND?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
  OR?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
  NOT?: Maybe<ChannelSubscriptionWhereInput[] | ChannelSubscriptionWhereInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface CostStructureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CostStructureWhereInput>;
  AND?: Maybe<
    CostStructureSubscriptionWhereInput[] | CostStructureSubscriptionWhereInput
  >;
  OR?: Maybe<
    CostStructureSubscriptionWhereInput[] | CostStructureSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CostStructureSubscriptionWhereInput[] | CostStructureSubscriptionWhereInput
  >;
}

export interface CustomerRelationshipSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerRelationshipWhereInput>;
  AND?: Maybe<
    | CustomerRelationshipSubscriptionWhereInput[]
    | CustomerRelationshipSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CustomerRelationshipSubscriptionWhereInput[]
    | CustomerRelationshipSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CustomerRelationshipSubscriptionWhereInput[]
    | CustomerRelationshipSubscriptionWhereInput
  >;
}

export interface CustomerSegmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerSegmentWhereInput>;
  AND?: Maybe<
    | CustomerSegmentSubscriptionWhereInput[]
    | CustomerSegmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CustomerSegmentSubscriptionWhereInput[]
    | CustomerSegmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CustomerSegmentSubscriptionWhereInput[]
    | CustomerSegmentSubscriptionWhereInput
  >;
}

export interface KeyActitvitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<KeyActitvityWhereInput>;
  AND?: Maybe<
    KeyActitvitySubscriptionWhereInput[] | KeyActitvitySubscriptionWhereInput
  >;
  OR?: Maybe<
    KeyActitvitySubscriptionWhereInput[] | KeyActitvitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    KeyActitvitySubscriptionWhereInput[] | KeyActitvitySubscriptionWhereInput
  >;
}

export interface KeyPartnerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<KeyPartnerWhereInput>;
  AND?: Maybe<
    KeyPartnerSubscriptionWhereInput[] | KeyPartnerSubscriptionWhereInput
  >;
  OR?: Maybe<
    KeyPartnerSubscriptionWhereInput[] | KeyPartnerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    KeyPartnerSubscriptionWhereInput[] | KeyPartnerSubscriptionWhereInput
  >;
}

export interface KeyResourceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<KeyResourceWhereInput>;
  AND?: Maybe<
    KeyResourceSubscriptionWhereInput[] | KeyResourceSubscriptionWhereInput
  >;
  OR?: Maybe<
    KeyResourceSubscriptionWhereInput[] | KeyResourceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    KeyResourceSubscriptionWhereInput[] | KeyResourceSubscriptionWhereInput
  >;
}

export interface PatternSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PatternWhereInput>;
  AND?: Maybe<PatternSubscriptionWhereInput[] | PatternSubscriptionWhereInput>;
  OR?: Maybe<PatternSubscriptionWhereInput[] | PatternSubscriptionWhereInput>;
  NOT?: Maybe<PatternSubscriptionWhereInput[] | PatternSubscriptionWhereInput>;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectWhereInput>;
  AND?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  OR?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  NOT?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
}

export interface RevenueStreamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RevenueStreamWhereInput>;
  AND?: Maybe<
    RevenueStreamSubscriptionWhereInput[] | RevenueStreamSubscriptionWhereInput
  >;
  OR?: Maybe<
    RevenueStreamSubscriptionWhereInput[] | RevenueStreamSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RevenueStreamSubscriptionWhereInput[] | RevenueStreamSubscriptionWhereInput
  >;
}

export interface TableSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TableWhereInput>;
  AND?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
  OR?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
  NOT?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ValuePropositionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ValuePropositionWhereInput>;
  AND?: Maybe<
    | ValuePropositionSubscriptionWhereInput[]
    | ValuePropositionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ValuePropositionSubscriptionWhereInput[]
    | ValuePropositionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ValuePropositionSubscriptionWhereInput[]
    | ValuePropositionSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Canvas {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CanvasPromise extends Promise<Canvas>, Fragmentable {
  id: () => Promise<ID_Output>;
  project_id: <T = ProjectPromise>() => T;
  pattern_ids: <T = FragmentableArray<Pattern>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TablePromise>() => T;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CanvasSubscription
  extends Promise<AsyncIterator<Canvas>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  project_id: <T = ProjectSubscription>() => T;
  pattern_ids: <T = Promise<AsyncIterator<PatternSubscription>>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TableSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CanvasNullablePromise
  extends Promise<Canvas | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  project_id: <T = ProjectPromise>() => T;
  pattern_ids: <T = FragmentableArray<Pattern>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TablePromise>() => T;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Project {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  user_id: <T = UserPromise>() => T;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user_id: <T = UserSubscription>() => T;
  canvas_ids: <T = Promise<AsyncIterator<CanvasSubscription>>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectNullablePromise
  extends Promise<Project | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user_id: <T = UserPromise>() => T;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  role: Role;
  password: String;
  verificationCode?: String;
  verified: Boolean;
  phoneNumber?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  project_ids: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  phoneNumber: () => Promise<String>;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  project_ids: <T = Promise<AsyncIterator<ProjectSubscription>>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  password: () => Promise<AsyncIterator<String>>;
  verificationCode: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  project_ids: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  phoneNumber: () => Promise<String>;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Pattern {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PatternPromise extends Promise<Pattern>, Fragmentable {
  id: () => Promise<ID_Output>;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TablePromise>() => T;
  company_ids: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatternSubscription
  extends Promise<AsyncIterator<Pattern>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  canvas_ids: <T = Promise<AsyncIterator<CanvasSubscription>>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TableSubscription>() => T;
  company_ids: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PatternNullablePromise
  extends Promise<Pattern | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TablePromise>() => T;
  company_ids: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Table {
  id: ID_Output;
}

export interface TablePromise extends Promise<Table>, Fragmentable {
  id: () => Promise<ID_Output>;
  key_partner_entry_ids: <T = FragmentableArray<KeyPartner>>(args?: {
    where?: KeyPartnerWhereInput;
    orderBy?: KeyPartnerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reventue_stream_entry_ids: <T = FragmentableArray<RevenueStream>>(args?: {
    where?: RevenueStreamWhereInput;
    orderBy?: RevenueStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key_activity_entry_ids: <T = FragmentableArray<KeyActitvity>>(args?: {
    where?: KeyActitvityWhereInput;
    orderBy?: KeyActitvityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer_relationship_entry_ids: <
    T = FragmentableArray<CustomerRelationship>
  >(args?: {
    where?: CustomerRelationshipWhereInput;
    orderBy?: CustomerRelationshipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_proposition_entry_ids: <
    T = FragmentableArray<ValueProposition>
  >(args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cost_structure_entry_ids: <T = FragmentableArray<CostStructure>>(args?: {
    where?: CostStructureWhereInput;
    orderBy?: CostStructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer_segment_entry_ids: <T = FragmentableArray<CustomerSegment>>(args?: {
    where?: CustomerSegmentWhereInput;
    orderBy?: CustomerSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key_resource_entry_ids: <T = FragmentableArray<KeyResource>>(args?: {
    where?: KeyResourceWhereInput;
    orderBy?: KeyResourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  channel_entry_ids: <T = FragmentableArray<Channel>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TableSubscription
  extends Promise<AsyncIterator<Table>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key_partner_entry_ids: <
    T = Promise<AsyncIterator<KeyPartnerSubscription>>
  >(args?: {
    where?: KeyPartnerWhereInput;
    orderBy?: KeyPartnerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reventue_stream_entry_ids: <
    T = Promise<AsyncIterator<RevenueStreamSubscription>>
  >(args?: {
    where?: RevenueStreamWhereInput;
    orderBy?: RevenueStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key_activity_entry_ids: <
    T = Promise<AsyncIterator<KeyActitvitySubscription>>
  >(args?: {
    where?: KeyActitvityWhereInput;
    orderBy?: KeyActitvityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer_relationship_entry_ids: <
    T = Promise<AsyncIterator<CustomerRelationshipSubscription>>
  >(args?: {
    where?: CustomerRelationshipWhereInput;
    orderBy?: CustomerRelationshipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_proposition_entry_ids: <
    T = Promise<AsyncIterator<ValuePropositionSubscription>>
  >(args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cost_structure_entry_ids: <
    T = Promise<AsyncIterator<CostStructureSubscription>>
  >(args?: {
    where?: CostStructureWhereInput;
    orderBy?: CostStructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer_segment_entry_ids: <
    T = Promise<AsyncIterator<CustomerSegmentSubscription>>
  >(args?: {
    where?: CustomerSegmentWhereInput;
    orderBy?: CustomerSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key_resource_entry_ids: <
    T = Promise<AsyncIterator<KeyResourceSubscription>>
  >(args?: {
    where?: KeyResourceWhereInput;
    orderBy?: KeyResourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  channel_entry_ids: <T = Promise<AsyncIterator<ChannelSubscription>>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TableNullablePromise
  extends Promise<Table | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key_partner_entry_ids: <T = FragmentableArray<KeyPartner>>(args?: {
    where?: KeyPartnerWhereInput;
    orderBy?: KeyPartnerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reventue_stream_entry_ids: <T = FragmentableArray<RevenueStream>>(args?: {
    where?: RevenueStreamWhereInput;
    orderBy?: RevenueStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key_activity_entry_ids: <T = FragmentableArray<KeyActitvity>>(args?: {
    where?: KeyActitvityWhereInput;
    orderBy?: KeyActitvityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer_relationship_entry_ids: <
    T = FragmentableArray<CustomerRelationship>
  >(args?: {
    where?: CustomerRelationshipWhereInput;
    orderBy?: CustomerRelationshipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_proposition_entry_ids: <
    T = FragmentableArray<ValueProposition>
  >(args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cost_structure_entry_ids: <T = FragmentableArray<CostStructure>>(args?: {
    where?: CostStructureWhereInput;
    orderBy?: CostStructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer_segment_entry_ids: <T = FragmentableArray<CustomerSegment>>(args?: {
    where?: CustomerSegmentWhereInput;
    orderBy?: CustomerSegmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key_resource_entry_ids: <T = FragmentableArray<KeyResource>>(args?: {
    where?: KeyResourceWhereInput;
    orderBy?: KeyResourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  channel_entry_ids: <T = FragmentableArray<Channel>>(args?: {
    where?: ChannelWhereInput;
    orderBy?: ChannelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface KeyPartner {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface KeyPartnerPromise extends Promise<KeyPartner>, Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface KeyPartnerSubscription
  extends Promise<AsyncIterator<KeyPartner>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface KeyPartnerNullablePromise
  extends Promise<KeyPartner | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RevenueStream {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RevenueStreamPromise
  extends Promise<RevenueStream>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RevenueStreamSubscription
  extends Promise<AsyncIterator<RevenueStream>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RevenueStreamNullablePromise
  extends Promise<RevenueStream | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface KeyActitvity {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface KeyActitvityPromise
  extends Promise<KeyActitvity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface KeyActitvitySubscription
  extends Promise<AsyncIterator<KeyActitvity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface KeyActitvityNullablePromise
  extends Promise<KeyActitvity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerRelationship {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerRelationshipPromise
  extends Promise<CustomerRelationship>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerRelationshipSubscription
  extends Promise<AsyncIterator<CustomerRelationship>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerRelationshipNullablePromise
  extends Promise<CustomerRelationship | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValueProposition {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ValuePropositionPromise
  extends Promise<ValueProposition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValuePropositionSubscription
  extends Promise<AsyncIterator<ValueProposition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ValuePropositionNullablePromise
  extends Promise<ValueProposition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CostStructure {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CostStructurePromise
  extends Promise<CostStructure>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CostStructureSubscription
  extends Promise<AsyncIterator<CostStructure>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CostStructureNullablePromise
  extends Promise<CostStructure | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSegment {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerSegmentPromise
  extends Promise<CustomerSegment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSegmentSubscription
  extends Promise<AsyncIterator<CustomerSegment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerSegmentNullablePromise
  extends Promise<CustomerSegment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface KeyResource {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface KeyResourcePromise extends Promise<KeyResource>, Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface KeyResourceSubscription
  extends Promise<AsyncIterator<KeyResource>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface KeyResourceNullablePromise
  extends Promise<KeyResource | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Channel {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ChannelPromise extends Promise<Channel>, Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChannelSubscription
  extends Promise<AsyncIterator<Channel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChannelNullablePromise
  extends Promise<Channel | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Company {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  pattern_ids: <T = FragmentableArray<Pattern>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pattern_ids: <T = Promise<AsyncIterator<PatternSubscription>>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pattern_ids: <T = FragmentableArray<Pattern>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CanvasConnection {
  pageInfo: PageInfo;
  edges: CanvasEdge[];
}

export interface CanvasConnectionPromise
  extends Promise<CanvasConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CanvasEdge>>() => T;
  aggregate: <T = AggregateCanvasPromise>() => T;
}

export interface CanvasConnectionSubscription
  extends Promise<AsyncIterator<CanvasConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CanvasEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCanvasSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CanvasEdge {
  node: Canvas;
  cursor: String;
}

export interface CanvasEdgePromise extends Promise<CanvasEdge>, Fragmentable {
  node: <T = CanvasPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CanvasEdgeSubscription
  extends Promise<AsyncIterator<CanvasEdge>>,
    Fragmentable {
  node: <T = CanvasSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCanvas {
  count: Int;
}

export interface AggregateCanvasPromise
  extends Promise<AggregateCanvas>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCanvasSubscription
  extends Promise<AsyncIterator<AggregateCanvas>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChannelConnection {
  pageInfo: PageInfo;
  edges: ChannelEdge[];
}

export interface ChannelConnectionPromise
  extends Promise<ChannelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChannelEdge>>() => T;
  aggregate: <T = AggregateChannelPromise>() => T;
}

export interface ChannelConnectionSubscription
  extends Promise<AsyncIterator<ChannelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChannelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChannelSubscription>() => T;
}

export interface ChannelEdge {
  node: Channel;
  cursor: String;
}

export interface ChannelEdgePromise extends Promise<ChannelEdge>, Fragmentable {
  node: <T = ChannelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChannelEdgeSubscription
  extends Promise<AsyncIterator<ChannelEdge>>,
    Fragmentable {
  node: <T = ChannelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChannel {
  count: Int;
}

export interface AggregateChannelPromise
  extends Promise<AggregateChannel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChannelSubscription
  extends Promise<AsyncIterator<AggregateChannel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CostStructureConnection {
  pageInfo: PageInfo;
  edges: CostStructureEdge[];
}

export interface CostStructureConnectionPromise
  extends Promise<CostStructureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CostStructureEdge>>() => T;
  aggregate: <T = AggregateCostStructurePromise>() => T;
}

export interface CostStructureConnectionSubscription
  extends Promise<AsyncIterator<CostStructureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CostStructureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCostStructureSubscription>() => T;
}

export interface CostStructureEdge {
  node: CostStructure;
  cursor: String;
}

export interface CostStructureEdgePromise
  extends Promise<CostStructureEdge>,
    Fragmentable {
  node: <T = CostStructurePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CostStructureEdgeSubscription
  extends Promise<AsyncIterator<CostStructureEdge>>,
    Fragmentable {
  node: <T = CostStructureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCostStructure {
  count: Int;
}

export interface AggregateCostStructurePromise
  extends Promise<AggregateCostStructure>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCostStructureSubscription
  extends Promise<AsyncIterator<AggregateCostStructure>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerRelationshipConnection {
  pageInfo: PageInfo;
  edges: CustomerRelationshipEdge[];
}

export interface CustomerRelationshipConnectionPromise
  extends Promise<CustomerRelationshipConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerRelationshipEdge>>() => T;
  aggregate: <T = AggregateCustomerRelationshipPromise>() => T;
}

export interface CustomerRelationshipConnectionSubscription
  extends Promise<AsyncIterator<CustomerRelationshipConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CustomerRelationshipEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCustomerRelationshipSubscription>() => T;
}

export interface CustomerRelationshipEdge {
  node: CustomerRelationship;
  cursor: String;
}

export interface CustomerRelationshipEdgePromise
  extends Promise<CustomerRelationshipEdge>,
    Fragmentable {
  node: <T = CustomerRelationshipPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerRelationshipEdgeSubscription
  extends Promise<AsyncIterator<CustomerRelationshipEdge>>,
    Fragmentable {
  node: <T = CustomerRelationshipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomerRelationship {
  count: Int;
}

export interface AggregateCustomerRelationshipPromise
  extends Promise<AggregateCustomerRelationship>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerRelationshipSubscription
  extends Promise<AsyncIterator<AggregateCustomerRelationship>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerSegmentConnection {
  pageInfo: PageInfo;
  edges: CustomerSegmentEdge[];
}

export interface CustomerSegmentConnectionPromise
  extends Promise<CustomerSegmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerSegmentEdge>>() => T;
  aggregate: <T = AggregateCustomerSegmentPromise>() => T;
}

export interface CustomerSegmentConnectionSubscription
  extends Promise<AsyncIterator<CustomerSegmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerSegmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSegmentSubscription>() => T;
}

export interface CustomerSegmentEdge {
  node: CustomerSegment;
  cursor: String;
}

export interface CustomerSegmentEdgePromise
  extends Promise<CustomerSegmentEdge>,
    Fragmentable {
  node: <T = CustomerSegmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerSegmentEdgeSubscription
  extends Promise<AsyncIterator<CustomerSegmentEdge>>,
    Fragmentable {
  node: <T = CustomerSegmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomerSegment {
  count: Int;
}

export interface AggregateCustomerSegmentPromise
  extends Promise<AggregateCustomerSegment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSegmentSubscription
  extends Promise<AsyncIterator<AggregateCustomerSegment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface KeyActitvityConnection {
  pageInfo: PageInfo;
  edges: KeyActitvityEdge[];
}

export interface KeyActitvityConnectionPromise
  extends Promise<KeyActitvityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<KeyActitvityEdge>>() => T;
  aggregate: <T = AggregateKeyActitvityPromise>() => T;
}

export interface KeyActitvityConnectionSubscription
  extends Promise<AsyncIterator<KeyActitvityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<KeyActitvityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateKeyActitvitySubscription>() => T;
}

export interface KeyActitvityEdge {
  node: KeyActitvity;
  cursor: String;
}

export interface KeyActitvityEdgePromise
  extends Promise<KeyActitvityEdge>,
    Fragmentable {
  node: <T = KeyActitvityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface KeyActitvityEdgeSubscription
  extends Promise<AsyncIterator<KeyActitvityEdge>>,
    Fragmentable {
  node: <T = KeyActitvitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateKeyActitvity {
  count: Int;
}

export interface AggregateKeyActitvityPromise
  extends Promise<AggregateKeyActitvity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateKeyActitvitySubscription
  extends Promise<AsyncIterator<AggregateKeyActitvity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface KeyPartnerConnection {
  pageInfo: PageInfo;
  edges: KeyPartnerEdge[];
}

export interface KeyPartnerConnectionPromise
  extends Promise<KeyPartnerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<KeyPartnerEdge>>() => T;
  aggregate: <T = AggregateKeyPartnerPromise>() => T;
}

export interface KeyPartnerConnectionSubscription
  extends Promise<AsyncIterator<KeyPartnerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<KeyPartnerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateKeyPartnerSubscription>() => T;
}

export interface KeyPartnerEdge {
  node: KeyPartner;
  cursor: String;
}

export interface KeyPartnerEdgePromise
  extends Promise<KeyPartnerEdge>,
    Fragmentable {
  node: <T = KeyPartnerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface KeyPartnerEdgeSubscription
  extends Promise<AsyncIterator<KeyPartnerEdge>>,
    Fragmentable {
  node: <T = KeyPartnerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateKeyPartner {
  count: Int;
}

export interface AggregateKeyPartnerPromise
  extends Promise<AggregateKeyPartner>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateKeyPartnerSubscription
  extends Promise<AsyncIterator<AggregateKeyPartner>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface KeyResourceConnection {
  pageInfo: PageInfo;
  edges: KeyResourceEdge[];
}

export interface KeyResourceConnectionPromise
  extends Promise<KeyResourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<KeyResourceEdge>>() => T;
  aggregate: <T = AggregateKeyResourcePromise>() => T;
}

export interface KeyResourceConnectionSubscription
  extends Promise<AsyncIterator<KeyResourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<KeyResourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateKeyResourceSubscription>() => T;
}

export interface KeyResourceEdge {
  node: KeyResource;
  cursor: String;
}

export interface KeyResourceEdgePromise
  extends Promise<KeyResourceEdge>,
    Fragmentable {
  node: <T = KeyResourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface KeyResourceEdgeSubscription
  extends Promise<AsyncIterator<KeyResourceEdge>>,
    Fragmentable {
  node: <T = KeyResourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateKeyResource {
  count: Int;
}

export interface AggregateKeyResourcePromise
  extends Promise<AggregateKeyResource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateKeyResourceSubscription
  extends Promise<AsyncIterator<AggregateKeyResource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PatternConnection {
  pageInfo: PageInfo;
  edges: PatternEdge[];
}

export interface PatternConnectionPromise
  extends Promise<PatternConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PatternEdge>>() => T;
  aggregate: <T = AggregatePatternPromise>() => T;
}

export interface PatternConnectionSubscription
  extends Promise<AsyncIterator<PatternConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PatternEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePatternSubscription>() => T;
}

export interface PatternEdge {
  node: Pattern;
  cursor: String;
}

export interface PatternEdgePromise extends Promise<PatternEdge>, Fragmentable {
  node: <T = PatternPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PatternEdgeSubscription
  extends Promise<AsyncIterator<PatternEdge>>,
    Fragmentable {
  node: <T = PatternSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePattern {
  count: Int;
}

export interface AggregatePatternPromise
  extends Promise<AggregatePattern>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePatternSubscription
  extends Promise<AsyncIterator<AggregatePattern>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RevenueStreamConnection {
  pageInfo: PageInfo;
  edges: RevenueStreamEdge[];
}

export interface RevenueStreamConnectionPromise
  extends Promise<RevenueStreamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RevenueStreamEdge>>() => T;
  aggregate: <T = AggregateRevenueStreamPromise>() => T;
}

export interface RevenueStreamConnectionSubscription
  extends Promise<AsyncIterator<RevenueStreamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RevenueStreamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRevenueStreamSubscription>() => T;
}

export interface RevenueStreamEdge {
  node: RevenueStream;
  cursor: String;
}

export interface RevenueStreamEdgePromise
  extends Promise<RevenueStreamEdge>,
    Fragmentable {
  node: <T = RevenueStreamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RevenueStreamEdgeSubscription
  extends Promise<AsyncIterator<RevenueStreamEdge>>,
    Fragmentable {
  node: <T = RevenueStreamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRevenueStream {
  count: Int;
}

export interface AggregateRevenueStreamPromise
  extends Promise<AggregateRevenueStream>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRevenueStreamSubscription
  extends Promise<AsyncIterator<AggregateRevenueStream>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TableConnection {
  pageInfo: PageInfo;
  edges: TableEdge[];
}

export interface TableConnectionPromise
  extends Promise<TableConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TableEdge>>() => T;
  aggregate: <T = AggregateTablePromise>() => T;
}

export interface TableConnectionSubscription
  extends Promise<AsyncIterator<TableConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TableEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTableSubscription>() => T;
}

export interface TableEdge {
  node: Table;
  cursor: String;
}

export interface TableEdgePromise extends Promise<TableEdge>, Fragmentable {
  node: <T = TablePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TableEdgeSubscription
  extends Promise<AsyncIterator<TableEdge>>,
    Fragmentable {
  node: <T = TableSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTable {
  count: Int;
}

export interface AggregateTablePromise
  extends Promise<AggregateTable>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTableSubscription
  extends Promise<AsyncIterator<AggregateTable>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValuePropositionConnection {
  pageInfo: PageInfo;
  edges: ValuePropositionEdge[];
}

export interface ValuePropositionConnectionPromise
  extends Promise<ValuePropositionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValuePropositionEdge>>() => T;
  aggregate: <T = AggregateValuePropositionPromise>() => T;
}

export interface ValuePropositionConnectionSubscription
  extends Promise<AsyncIterator<ValuePropositionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ValuePropositionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateValuePropositionSubscription>() => T;
}

export interface ValuePropositionEdge {
  node: ValueProposition;
  cursor: String;
}

export interface ValuePropositionEdgePromise
  extends Promise<ValuePropositionEdge>,
    Fragmentable {
  node: <T = ValuePropositionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ValuePropositionEdgeSubscription
  extends Promise<AsyncIterator<ValuePropositionEdge>>,
    Fragmentable {
  node: <T = ValuePropositionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateValueProposition {
  count: Int;
}

export interface AggregateValuePropositionPromise
  extends Promise<AggregateValueProposition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValuePropositionSubscription
  extends Promise<AsyncIterator<AggregateValueProposition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CanvasSubscriptionPayload {
  mutation: MutationType;
  node: Canvas;
  updatedFields: String[];
  previousValues: CanvasPreviousValues;
}

export interface CanvasSubscriptionPayloadPromise
  extends Promise<CanvasSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CanvasPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CanvasPreviousValuesPromise>() => T;
}

export interface CanvasSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CanvasSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CanvasSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CanvasPreviousValuesSubscription>() => T;
}

export interface CanvasPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CanvasPreviousValuesPromise
  extends Promise<CanvasPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CanvasPreviousValuesSubscription
  extends Promise<AsyncIterator<CanvasPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChannelSubscriptionPayload {
  mutation: MutationType;
  node: Channel;
  updatedFields: String[];
  previousValues: ChannelPreviousValues;
}

export interface ChannelSubscriptionPayloadPromise
  extends Promise<ChannelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChannelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChannelPreviousValuesPromise>() => T;
}

export interface ChannelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChannelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChannelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChannelPreviousValuesSubscription>() => T;
}

export interface ChannelPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ChannelPreviousValuesPromise
  extends Promise<ChannelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChannelPreviousValuesSubscription
  extends Promise<AsyncIterator<ChannelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CostStructureSubscriptionPayload {
  mutation: MutationType;
  node: CostStructure;
  updatedFields: String[];
  previousValues: CostStructurePreviousValues;
}

export interface CostStructureSubscriptionPayloadPromise
  extends Promise<CostStructureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CostStructurePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CostStructurePreviousValuesPromise>() => T;
}

export interface CostStructureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CostStructureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CostStructureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CostStructurePreviousValuesSubscription>() => T;
}

export interface CostStructurePreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CostStructurePreviousValuesPromise
  extends Promise<CostStructurePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CostStructurePreviousValuesSubscription
  extends Promise<AsyncIterator<CostStructurePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerRelationshipSubscriptionPayload {
  mutation: MutationType;
  node: CustomerRelationship;
  updatedFields: String[];
  previousValues: CustomerRelationshipPreviousValues;
}

export interface CustomerRelationshipSubscriptionPayloadPromise
  extends Promise<CustomerRelationshipSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerRelationshipPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerRelationshipPreviousValuesPromise>() => T;
}

export interface CustomerRelationshipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerRelationshipSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerRelationshipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerRelationshipPreviousValuesSubscription>() => T;
}

export interface CustomerRelationshipPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerRelationshipPreviousValuesPromise
  extends Promise<CustomerRelationshipPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerRelationshipPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerRelationshipPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerSegmentSubscriptionPayload {
  mutation: MutationType;
  node: CustomerSegment;
  updatedFields: String[];
  previousValues: CustomerSegmentPreviousValues;
}

export interface CustomerSegmentSubscriptionPayloadPromise
  extends Promise<CustomerSegmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerSegmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerSegmentPreviousValuesPromise>() => T;
}

export interface CustomerSegmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSegmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSegmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerSegmentPreviousValuesSubscription>() => T;
}

export interface CustomerSegmentPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerSegmentPreviousValuesPromise
  extends Promise<CustomerSegmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSegmentPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerSegmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface KeyActitvitySubscriptionPayload {
  mutation: MutationType;
  node: KeyActitvity;
  updatedFields: String[];
  previousValues: KeyActitvityPreviousValues;
}

export interface KeyActitvitySubscriptionPayloadPromise
  extends Promise<KeyActitvitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = KeyActitvityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = KeyActitvityPreviousValuesPromise>() => T;
}

export interface KeyActitvitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeyActitvitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = KeyActitvitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = KeyActitvityPreviousValuesSubscription>() => T;
}

export interface KeyActitvityPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface KeyActitvityPreviousValuesPromise
  extends Promise<KeyActitvityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface KeyActitvityPreviousValuesSubscription
  extends Promise<AsyncIterator<KeyActitvityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface KeyPartnerSubscriptionPayload {
  mutation: MutationType;
  node: KeyPartner;
  updatedFields: String[];
  previousValues: KeyPartnerPreviousValues;
}

export interface KeyPartnerSubscriptionPayloadPromise
  extends Promise<KeyPartnerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = KeyPartnerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = KeyPartnerPreviousValuesPromise>() => T;
}

export interface KeyPartnerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeyPartnerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = KeyPartnerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = KeyPartnerPreviousValuesSubscription>() => T;
}

export interface KeyPartnerPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface KeyPartnerPreviousValuesPromise
  extends Promise<KeyPartnerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface KeyPartnerPreviousValuesSubscription
  extends Promise<AsyncIterator<KeyPartnerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface KeyResourceSubscriptionPayload {
  mutation: MutationType;
  node: KeyResource;
  updatedFields: String[];
  previousValues: KeyResourcePreviousValues;
}

export interface KeyResourceSubscriptionPayloadPromise
  extends Promise<KeyResourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = KeyResourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = KeyResourcePreviousValuesPromise>() => T;
}

export interface KeyResourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeyResourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = KeyResourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = KeyResourcePreviousValuesSubscription>() => T;
}

export interface KeyResourcePreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface KeyResourcePreviousValuesPromise
  extends Promise<KeyResourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface KeyResourcePreviousValuesSubscription
  extends Promise<AsyncIterator<KeyResourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PatternSubscriptionPayload {
  mutation: MutationType;
  node: Pattern;
  updatedFields: String[];
  previousValues: PatternPreviousValues;
}

export interface PatternSubscriptionPayloadPromise
  extends Promise<PatternSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PatternPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PatternPreviousValuesPromise>() => T;
}

export interface PatternSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PatternSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PatternSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PatternPreviousValuesSubscription>() => T;
}

export interface PatternPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PatternPreviousValuesPromise
  extends Promise<PatternPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatternPreviousValuesSubscription
  extends Promise<AsyncIterator<PatternPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RevenueStreamSubscriptionPayload {
  mutation: MutationType;
  node: RevenueStream;
  updatedFields: String[];
  previousValues: RevenueStreamPreviousValues;
}

export interface RevenueStreamSubscriptionPayloadPromise
  extends Promise<RevenueStreamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RevenueStreamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RevenueStreamPreviousValuesPromise>() => T;
}

export interface RevenueStreamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RevenueStreamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RevenueStreamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RevenueStreamPreviousValuesSubscription>() => T;
}

export interface RevenueStreamPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RevenueStreamPreviousValuesPromise
  extends Promise<RevenueStreamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RevenueStreamPreviousValuesSubscription
  extends Promise<AsyncIterator<RevenueStreamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TableSubscriptionPayload {
  mutation: MutationType;
  node: Table;
  updatedFields: String[];
  previousValues: TablePreviousValues;
}

export interface TableSubscriptionPayloadPromise
  extends Promise<TableSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TablePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TablePreviousValuesPromise>() => T;
}

export interface TableSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TableSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TableSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TablePreviousValuesSubscription>() => T;
}

export interface TablePreviousValues {
  id: ID_Output;
}

export interface TablePreviousValuesPromise
  extends Promise<TablePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface TablePreviousValuesSubscription
  extends Promise<AsyncIterator<TablePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  role: Role;
  password: String;
  verificationCode?: String;
  verified: Boolean;
  phoneNumber?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  phoneNumber: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  password: () => Promise<AsyncIterator<String>>;
  verificationCode: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ValuePropositionSubscriptionPayload {
  mutation: MutationType;
  node: ValueProposition;
  updatedFields: String[];
  previousValues: ValuePropositionPreviousValues;
}

export interface ValuePropositionSubscriptionPayloadPromise
  extends Promise<ValuePropositionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValuePropositionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ValuePropositionPreviousValuesPromise>() => T;
}

export interface ValuePropositionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValuePropositionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValuePropositionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ValuePropositionPreviousValuesSubscription>() => T;
}

export interface ValuePropositionPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ValuePropositionPreviousValuesPromise
  extends Promise<ValuePropositionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValuePropositionPreviousValuesSubscription
  extends Promise<AsyncIterator<ValuePropositionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "Canvas",
    embedded: false
  },
  {
    name: "Pattern",
    embedded: false
  },
  {
    name: "Table",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "KeyPartner",
    embedded: false
  },
  {
    name: "RevenueStream",
    embedded: false
  },
  {
    name: "KeyActitvity",
    embedded: false
  },
  {
    name: "CustomerRelationship",
    embedded: false
  },
  {
    name: "ValueProposition",
    embedded: false
  },
  {
    name: "CostStructure",
    embedded: false
  },
  {
    name: "CustomerSegment",
    embedded: false
  },
  {
    name: "KeyResource",
    embedded: false
  },
  {
    name: "Channel",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://canvasprisma-9a0fe0d5ce.herokuapp.com/BusinessModelDigitalHealthBackend/dev`,
  secret: `AiD-CaNvAs-PrOjEcT-2019`
});
export const prisma = new Prisma();
