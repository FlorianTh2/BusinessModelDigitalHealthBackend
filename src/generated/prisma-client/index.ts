// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  actor: (where?: ActorWhereInput) => Promise<boolean>;
  canvas: (where?: CanvasWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  expense: (where?: ExpenseWhereInput) => Promise<boolean>;
  networkEffect: (where?: NetworkEffectWhereInput) => Promise<boolean>;
  pattern: (where?: PatternWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  regulatory: (where?: RegulatoryWhereInput) => Promise<boolean>;
  revenue: (where?: RevenueWhereInput) => Promise<boolean>;
  strategy: (where?: StrategyWhereInput) => Promise<boolean>;
  strategyPattern: (where?: StrategyPatternWhereInput) => Promise<boolean>;
  table: (where?: TableWhereInput) => Promise<boolean>;
  technicalInfrastructure: (
    where?: TechnicalInfrastructureWhereInput
  ) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  valueCreation: (where?: ValueCreationWhereInput) => Promise<boolean>;
  valueDelivery: (where?: ValueDeliveryWhereInput) => Promise<boolean>;
  valueProposition: (where?: ValuePropositionWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  actor: (where: ActorWhereUniqueInput) => ActorNullablePromise;
  actors: (args?: {
    where?: ActorWhereInput;
    orderBy?: ActorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Actor>;
  actorsConnection: (args?: {
    where?: ActorWhereInput;
    orderBy?: ActorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActorConnectionPromise;
  canvas: (where: CanvasWhereUniqueInput) => CanvasNullablePromise;
  canvases: (args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Canvas>;
  canvasesConnection: (args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CanvasConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  expense: (where: ExpenseWhereUniqueInput) => ExpenseNullablePromise;
  expenses: (args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Expense>;
  expensesConnection: (args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseConnectionPromise;
  networkEffect: (
    where: NetworkEffectWhereUniqueInput
  ) => NetworkEffectNullablePromise;
  networkEffects: (args?: {
    where?: NetworkEffectWhereInput;
    orderBy?: NetworkEffectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NetworkEffect>;
  networkEffectsConnection: (args?: {
    where?: NetworkEffectWhereInput;
    orderBy?: NetworkEffectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NetworkEffectConnectionPromise;
  pattern: (where: PatternWhereUniqueInput) => PatternNullablePromise;
  patterns: (args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pattern>;
  patternsConnection: (args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PatternConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectNullablePromise;
  projects: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Project>;
  projectsConnection: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectConnectionPromise;
  regulatory: (where: RegulatoryWhereUniqueInput) => RegulatoryNullablePromise;
  regulatories: (args?: {
    where?: RegulatoryWhereInput;
    orderBy?: RegulatoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Regulatory>;
  regulatoriesConnection: (args?: {
    where?: RegulatoryWhereInput;
    orderBy?: RegulatoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RegulatoryConnectionPromise;
  revenue: (where: RevenueWhereUniqueInput) => RevenueNullablePromise;
  revenues: (args?: {
    where?: RevenueWhereInput;
    orderBy?: RevenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Revenue>;
  revenuesConnection: (args?: {
    where?: RevenueWhereInput;
    orderBy?: RevenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RevenueConnectionPromise;
  strategy: (where: StrategyWhereUniqueInput) => StrategyNullablePromise;
  strategies: (args?: {
    where?: StrategyWhereInput;
    orderBy?: StrategyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Strategy>;
  strategiesConnection: (args?: {
    where?: StrategyWhereInput;
    orderBy?: StrategyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StrategyConnectionPromise;
  strategyPattern: (
    where: StrategyPatternWhereUniqueInput
  ) => StrategyPatternNullablePromise;
  strategyPatterns: (args?: {
    where?: StrategyPatternWhereInput;
    orderBy?: StrategyPatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StrategyPattern>;
  strategyPatternsConnection: (args?: {
    where?: StrategyPatternWhereInput;
    orderBy?: StrategyPatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StrategyPatternConnectionPromise;
  table: (where: TableWhereUniqueInput) => TableNullablePromise;
  tables: (args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Table>;
  tablesConnection: (args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TableConnectionPromise;
  technicalInfrastructure: (
    where: TechnicalInfrastructureWhereUniqueInput
  ) => TechnicalInfrastructureNullablePromise;
  technicalInfrastructures: (args?: {
    where?: TechnicalInfrastructureWhereInput;
    orderBy?: TechnicalInfrastructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TechnicalInfrastructure>;
  technicalInfrastructuresConnection: (args?: {
    where?: TechnicalInfrastructureWhereInput;
    orderBy?: TechnicalInfrastructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TechnicalInfrastructureConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  valueCreation: (
    where: ValueCreationWhereUniqueInput
  ) => ValueCreationNullablePromise;
  valueCreations: (args?: {
    where?: ValueCreationWhereInput;
    orderBy?: ValueCreationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ValueCreation>;
  valueCreationsConnection: (args?: {
    where?: ValueCreationWhereInput;
    orderBy?: ValueCreationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ValueCreationConnectionPromise;
  valueDelivery: (
    where: ValueDeliveryWhereUniqueInput
  ) => ValueDeliveryNullablePromise;
  valueDeliveries: (args?: {
    where?: ValueDeliveryWhereInput;
    orderBy?: ValueDeliveryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ValueDelivery>;
  valueDeliveriesConnection: (args?: {
    where?: ValueDeliveryWhereInput;
    orderBy?: ValueDeliveryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ValueDeliveryConnectionPromise;
  valueProposition: (
    where: ValuePropositionWhereUniqueInput
  ) => ValuePropositionNullablePromise;
  valuePropositions: (args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ValueProposition>;
  valuePropositionsConnection: (args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ValuePropositionConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActor: (data: ActorCreateInput) => ActorPromise;
  updateActor: (args: {
    data: ActorUpdateInput;
    where: ActorWhereUniqueInput;
  }) => ActorPromise;
  updateManyActors: (args: {
    data: ActorUpdateManyMutationInput;
    where?: ActorWhereInput;
  }) => BatchPayloadPromise;
  upsertActor: (args: {
    where: ActorWhereUniqueInput;
    create: ActorCreateInput;
    update: ActorUpdateInput;
  }) => ActorPromise;
  deleteActor: (where: ActorWhereUniqueInput) => ActorPromise;
  deleteManyActors: (where?: ActorWhereInput) => BatchPayloadPromise;
  createCanvas: (data: CanvasCreateInput) => CanvasPromise;
  updateCanvas: (args: {
    data: CanvasUpdateInput;
    where: CanvasWhereUniqueInput;
  }) => CanvasPromise;
  updateManyCanvases: (args: {
    data: CanvasUpdateManyMutationInput;
    where?: CanvasWhereInput;
  }) => BatchPayloadPromise;
  upsertCanvas: (args: {
    where: CanvasWhereUniqueInput;
    create: CanvasCreateInput;
    update: CanvasUpdateInput;
  }) => CanvasPromise;
  deleteCanvas: (where: CanvasWhereUniqueInput) => CanvasPromise;
  deleteManyCanvases: (where?: CanvasWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createExpense: (data: ExpenseCreateInput) => ExpensePromise;
  updateExpense: (args: {
    data: ExpenseUpdateInput;
    where: ExpenseWhereUniqueInput;
  }) => ExpensePromise;
  updateManyExpenses: (args: {
    data: ExpenseUpdateManyMutationInput;
    where?: ExpenseWhereInput;
  }) => BatchPayloadPromise;
  upsertExpense: (args: {
    where: ExpenseWhereUniqueInput;
    create: ExpenseCreateInput;
    update: ExpenseUpdateInput;
  }) => ExpensePromise;
  deleteExpense: (where: ExpenseWhereUniqueInput) => ExpensePromise;
  deleteManyExpenses: (where?: ExpenseWhereInput) => BatchPayloadPromise;
  createNetworkEffect: (data: NetworkEffectCreateInput) => NetworkEffectPromise;
  updateNetworkEffect: (args: {
    data: NetworkEffectUpdateInput;
    where: NetworkEffectWhereUniqueInput;
  }) => NetworkEffectPromise;
  updateManyNetworkEffects: (args: {
    data: NetworkEffectUpdateManyMutationInput;
    where?: NetworkEffectWhereInput;
  }) => BatchPayloadPromise;
  upsertNetworkEffect: (args: {
    where: NetworkEffectWhereUniqueInput;
    create: NetworkEffectCreateInput;
    update: NetworkEffectUpdateInput;
  }) => NetworkEffectPromise;
  deleteNetworkEffect: (
    where: NetworkEffectWhereUniqueInput
  ) => NetworkEffectPromise;
  deleteManyNetworkEffects: (
    where?: NetworkEffectWhereInput
  ) => BatchPayloadPromise;
  createPattern: (data: PatternCreateInput) => PatternPromise;
  updatePattern: (args: {
    data: PatternUpdateInput;
    where: PatternWhereUniqueInput;
  }) => PatternPromise;
  updateManyPatterns: (args: {
    data: PatternUpdateManyMutationInput;
    where?: PatternWhereInput;
  }) => BatchPayloadPromise;
  upsertPattern: (args: {
    where: PatternWhereUniqueInput;
    create: PatternCreateInput;
    update: PatternUpdateInput;
  }) => PatternPromise;
  deletePattern: (where: PatternWhereUniqueInput) => PatternPromise;
  deleteManyPatterns: (where?: PatternWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (args: {
    data: ProjectUpdateInput;
    where: ProjectWhereUniqueInput;
  }) => ProjectPromise;
  updateManyProjects: (args: {
    data: ProjectUpdateManyMutationInput;
    where?: ProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertProject: (args: {
    where: ProjectWhereUniqueInput;
    create: ProjectCreateInput;
    update: ProjectUpdateInput;
  }) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createRegulatory: (data: RegulatoryCreateInput) => RegulatoryPromise;
  updateRegulatory: (args: {
    data: RegulatoryUpdateInput;
    where: RegulatoryWhereUniqueInput;
  }) => RegulatoryPromise;
  updateManyRegulatories: (args: {
    data: RegulatoryUpdateManyMutationInput;
    where?: RegulatoryWhereInput;
  }) => BatchPayloadPromise;
  upsertRegulatory: (args: {
    where: RegulatoryWhereUniqueInput;
    create: RegulatoryCreateInput;
    update: RegulatoryUpdateInput;
  }) => RegulatoryPromise;
  deleteRegulatory: (where: RegulatoryWhereUniqueInput) => RegulatoryPromise;
  deleteManyRegulatories: (where?: RegulatoryWhereInput) => BatchPayloadPromise;
  createRevenue: (data: RevenueCreateInput) => RevenuePromise;
  updateRevenue: (args: {
    data: RevenueUpdateInput;
    where: RevenueWhereUniqueInput;
  }) => RevenuePromise;
  updateManyRevenues: (args: {
    data: RevenueUpdateManyMutationInput;
    where?: RevenueWhereInput;
  }) => BatchPayloadPromise;
  upsertRevenue: (args: {
    where: RevenueWhereUniqueInput;
    create: RevenueCreateInput;
    update: RevenueUpdateInput;
  }) => RevenuePromise;
  deleteRevenue: (where: RevenueWhereUniqueInput) => RevenuePromise;
  deleteManyRevenues: (where?: RevenueWhereInput) => BatchPayloadPromise;
  createStrategy: (data: StrategyCreateInput) => StrategyPromise;
  updateStrategy: (args: {
    data: StrategyUpdateInput;
    where: StrategyWhereUniqueInput;
  }) => StrategyPromise;
  updateManyStrategies: (args: {
    data: StrategyUpdateManyMutationInput;
    where?: StrategyWhereInput;
  }) => BatchPayloadPromise;
  upsertStrategy: (args: {
    where: StrategyWhereUniqueInput;
    create: StrategyCreateInput;
    update: StrategyUpdateInput;
  }) => StrategyPromise;
  deleteStrategy: (where: StrategyWhereUniqueInput) => StrategyPromise;
  deleteManyStrategies: (where?: StrategyWhereInput) => BatchPayloadPromise;
  createStrategyPattern: (
    data: StrategyPatternCreateInput
  ) => StrategyPatternPromise;
  updateStrategyPattern: (args: {
    data: StrategyPatternUpdateInput;
    where: StrategyPatternWhereUniqueInput;
  }) => StrategyPatternPromise;
  updateManyStrategyPatterns: (args: {
    data: StrategyPatternUpdateManyMutationInput;
    where?: StrategyPatternWhereInput;
  }) => BatchPayloadPromise;
  upsertStrategyPattern: (args: {
    where: StrategyPatternWhereUniqueInput;
    create: StrategyPatternCreateInput;
    update: StrategyPatternUpdateInput;
  }) => StrategyPatternPromise;
  deleteStrategyPattern: (
    where: StrategyPatternWhereUniqueInput
  ) => StrategyPatternPromise;
  deleteManyStrategyPatterns: (
    where?: StrategyPatternWhereInput
  ) => BatchPayloadPromise;
  createTable: (data: TableCreateInput) => TablePromise;
  updateTable: (args: {
    data: TableUpdateInput;
    where: TableWhereUniqueInput;
  }) => TablePromise;
  upsertTable: (args: {
    where: TableWhereUniqueInput;
    create: TableCreateInput;
    update: TableUpdateInput;
  }) => TablePromise;
  deleteTable: (where: TableWhereUniqueInput) => TablePromise;
  deleteManyTables: (where?: TableWhereInput) => BatchPayloadPromise;
  createTechnicalInfrastructure: (
    data: TechnicalInfrastructureCreateInput
  ) => TechnicalInfrastructurePromise;
  updateTechnicalInfrastructure: (args: {
    data: TechnicalInfrastructureUpdateInput;
    where: TechnicalInfrastructureWhereUniqueInput;
  }) => TechnicalInfrastructurePromise;
  updateManyTechnicalInfrastructures: (args: {
    data: TechnicalInfrastructureUpdateManyMutationInput;
    where?: TechnicalInfrastructureWhereInput;
  }) => BatchPayloadPromise;
  upsertTechnicalInfrastructure: (args: {
    where: TechnicalInfrastructureWhereUniqueInput;
    create: TechnicalInfrastructureCreateInput;
    update: TechnicalInfrastructureUpdateInput;
  }) => TechnicalInfrastructurePromise;
  deleteTechnicalInfrastructure: (
    where: TechnicalInfrastructureWhereUniqueInput
  ) => TechnicalInfrastructurePromise;
  deleteManyTechnicalInfrastructures: (
    where?: TechnicalInfrastructureWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createValueCreation: (data: ValueCreationCreateInput) => ValueCreationPromise;
  updateValueCreation: (args: {
    data: ValueCreationUpdateInput;
    where: ValueCreationWhereUniqueInput;
  }) => ValueCreationPromise;
  updateManyValueCreations: (args: {
    data: ValueCreationUpdateManyMutationInput;
    where?: ValueCreationWhereInput;
  }) => BatchPayloadPromise;
  upsertValueCreation: (args: {
    where: ValueCreationWhereUniqueInput;
    create: ValueCreationCreateInput;
    update: ValueCreationUpdateInput;
  }) => ValueCreationPromise;
  deleteValueCreation: (
    where: ValueCreationWhereUniqueInput
  ) => ValueCreationPromise;
  deleteManyValueCreations: (
    where?: ValueCreationWhereInput
  ) => BatchPayloadPromise;
  createValueDelivery: (data: ValueDeliveryCreateInput) => ValueDeliveryPromise;
  updateValueDelivery: (args: {
    data: ValueDeliveryUpdateInput;
    where: ValueDeliveryWhereUniqueInput;
  }) => ValueDeliveryPromise;
  updateManyValueDeliveries: (args: {
    data: ValueDeliveryUpdateManyMutationInput;
    where?: ValueDeliveryWhereInput;
  }) => BatchPayloadPromise;
  upsertValueDelivery: (args: {
    where: ValueDeliveryWhereUniqueInput;
    create: ValueDeliveryCreateInput;
    update: ValueDeliveryUpdateInput;
  }) => ValueDeliveryPromise;
  deleteValueDelivery: (
    where: ValueDeliveryWhereUniqueInput
  ) => ValueDeliveryPromise;
  deleteManyValueDeliveries: (
    where?: ValueDeliveryWhereInput
  ) => BatchPayloadPromise;
  createValueProposition: (
    data: ValuePropositionCreateInput
  ) => ValuePropositionPromise;
  updateValueProposition: (args: {
    data: ValuePropositionUpdateInput;
    where: ValuePropositionWhereUniqueInput;
  }) => ValuePropositionPromise;
  updateManyValuePropositions: (args: {
    data: ValuePropositionUpdateManyMutationInput;
    where?: ValuePropositionWhereInput;
  }) => BatchPayloadPromise;
  upsertValueProposition: (args: {
    where: ValuePropositionWhereUniqueInput;
    create: ValuePropositionCreateInput;
    update: ValuePropositionUpdateInput;
  }) => ValuePropositionPromise;
  deleteValueProposition: (
    where: ValuePropositionWhereUniqueInput
  ) => ValuePropositionPromise;
  deleteManyValuePropositions: (
    where?: ValuePropositionWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  actor: (
    where?: ActorSubscriptionWhereInput
  ) => ActorSubscriptionPayloadSubscription;
  canvas: (
    where?: CanvasSubscriptionWhereInput
  ) => CanvasSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  expense: (
    where?: ExpenseSubscriptionWhereInput
  ) => ExpenseSubscriptionPayloadSubscription;
  networkEffect: (
    where?: NetworkEffectSubscriptionWhereInput
  ) => NetworkEffectSubscriptionPayloadSubscription;
  pattern: (
    where?: PatternSubscriptionWhereInput
  ) => PatternSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  regulatory: (
    where?: RegulatorySubscriptionWhereInput
  ) => RegulatorySubscriptionPayloadSubscription;
  revenue: (
    where?: RevenueSubscriptionWhereInput
  ) => RevenueSubscriptionPayloadSubscription;
  strategy: (
    where?: StrategySubscriptionWhereInput
  ) => StrategySubscriptionPayloadSubscription;
  strategyPattern: (
    where?: StrategyPatternSubscriptionWhereInput
  ) => StrategyPatternSubscriptionPayloadSubscription;
  table: (
    where?: TableSubscriptionWhereInput
  ) => TableSubscriptionPayloadSubscription;
  technicalInfrastructure: (
    where?: TechnicalInfrastructureSubscriptionWhereInput
  ) => TechnicalInfrastructureSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  valueCreation: (
    where?: ValueCreationSubscriptionWhereInput
  ) => ValueCreationSubscriptionPayloadSubscription;
  valueDelivery: (
    where?: ValueDeliverySubscriptionWhereInput
  ) => ValueDeliverySubscriptionPayloadSubscription;
  valueProposition: (
    where?: ValuePropositionSubscriptionWhereInput
  ) => ValuePropositionSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Role = "USER" | "ADMIN";

export type TableOrderByInput = "id_ASC" | "id_DESC";

export type ActorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ValuePropositionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CanvasOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StrategyPatternOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PatternOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "actorWeight_ASC"
  | "actorWeight_DESC"
  | "valuePropositionWeight_ASC"
  | "valuePropositionWeight_DESC"
  | "valueCreationWeight_ASC"
  | "valueCreationWeight_DESC"
  | "valueDeliveryWeight_ASC"
  | "valueDeliveryWeight_DESC"
  | "revenueWeight_ASC"
  | "revenueWeight_DESC"
  | "expenseWeight_ASC"
  | "expenseWeight_DESC"
  | "networkEffectWeight_ASC"
  | "networkEffectWeight_DESC"
  | "regulatoryWeight_ASC"
  | "regulatoryWeight_DESC"
  | "technicalInfrastructureWeight_ASC"
  | "technicalInfrastructureWeight_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ValueCreationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ValueDeliveryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RevenueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExpenseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NetworkEffectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TechnicalInfrastructureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RegulatoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "note_ASC"
  | "note_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StrategyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "role_ASC"
  | "role_DESC"
  | "password_ASC"
  | "password_DESC"
  | "verificationCode_ASC"
  | "verificationCode_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TableWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  actor_entry_ids_every?: Maybe<ActorWhereInput>;
  actor_entry_ids_some?: Maybe<ActorWhereInput>;
  actor_entry_ids_none?: Maybe<ActorWhereInput>;
  value_proposition_entry_ids_every?: Maybe<ValuePropositionWhereInput>;
  value_proposition_entry_ids_some?: Maybe<ValuePropositionWhereInput>;
  value_proposition_entry_ids_none?: Maybe<ValuePropositionWhereInput>;
  value_creation_entry_ids_every?: Maybe<ValueCreationWhereInput>;
  value_creation_entry_ids_some?: Maybe<ValueCreationWhereInput>;
  value_creation_entry_ids_none?: Maybe<ValueCreationWhereInput>;
  value_delivery_entry_ids_every?: Maybe<ValueDeliveryWhereInput>;
  value_delivery_entry_ids_some?: Maybe<ValueDeliveryWhereInput>;
  value_delivery_entry_ids_none?: Maybe<ValueDeliveryWhereInput>;
  revenue_entry_ids_every?: Maybe<RevenueWhereInput>;
  revenue_entry_ids_some?: Maybe<RevenueWhereInput>;
  revenue_entry_ids_none?: Maybe<RevenueWhereInput>;
  expense_entry_ids_every?: Maybe<ExpenseWhereInput>;
  expense_entry_ids_some?: Maybe<ExpenseWhereInput>;
  expense_entry_ids_none?: Maybe<ExpenseWhereInput>;
  network_effect_entry_ids_every?: Maybe<NetworkEffectWhereInput>;
  network_effect_entry_ids_some?: Maybe<NetworkEffectWhereInput>;
  network_effect_entry_ids_none?: Maybe<NetworkEffectWhereInput>;
  technical_infrastructure_entry_ids_every?: Maybe<
    TechnicalInfrastructureWhereInput
  >;
  technical_infrastructure_entry_ids_some?: Maybe<
    TechnicalInfrastructureWhereInput
  >;
  technical_infrastructure_entry_ids_none?: Maybe<
    TechnicalInfrastructureWhereInput
  >;
  regulatory_entry_ids_every?: Maybe<RegulatoryWhereInput>;
  regulatory_entry_ids_some?: Maybe<RegulatoryWhereInput>;
  regulatory_entry_ids_none?: Maybe<RegulatoryWhereInput>;
  AND?: Maybe<TableWhereInput[] | TableWhereInput>;
  OR?: Maybe<TableWhereInput[] | TableWhereInput>;
  NOT?: Maybe<TableWhereInput[] | TableWhereInput>;
}

export interface ActorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ActorWhereInput[] | ActorWhereInput>;
  OR?: Maybe<ActorWhereInput[] | ActorWhereInput>;
  NOT?: Maybe<ActorWhereInput[] | ActorWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  project_ids_every?: Maybe<ProjectWhereInput>;
  project_ids_some?: Maybe<ProjectWhereInput>;
  project_ids_none?: Maybe<ProjectWhereInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verificationCode_not?: Maybe<String>;
  verificationCode_in?: Maybe<String[] | String>;
  verificationCode_not_in?: Maybe<String[] | String>;
  verificationCode_lt?: Maybe<String>;
  verificationCode_lte?: Maybe<String>;
  verificationCode_gt?: Maybe<String>;
  verificationCode_gte?: Maybe<String>;
  verificationCode_contains?: Maybe<String>;
  verificationCode_not_contains?: Maybe<String>;
  verificationCode_starts_with?: Maybe<String>;
  verificationCode_not_starts_with?: Maybe<String>;
  verificationCode_ends_with?: Maybe<String>;
  verificationCode_not_ends_with?: Maybe<String>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user_id?: Maybe<UserWhereInput>;
  canvas_ids_every?: Maybe<CanvasWhereInput>;
  canvas_ids_some?: Maybe<CanvasWhereInput>;
  canvas_ids_none?: Maybe<CanvasWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  OR?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  NOT?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
}

export interface CanvasWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  project_id?: Maybe<ProjectWhereInput>;
  strategy_id?: Maybe<StrategyWhereInput>;
  pattern_ids_every?: Maybe<PatternWhereInput>;
  pattern_ids_some?: Maybe<PatternWhereInput>;
  pattern_ids_none?: Maybe<PatternWhereInput>;
  table_id?: Maybe<TableWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CanvasWhereInput[] | CanvasWhereInput>;
  OR?: Maybe<CanvasWhereInput[] | CanvasWhereInput>;
  NOT?: Maybe<CanvasWhereInput[] | CanvasWhereInput>;
}

export interface StrategyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  canvas_ids_every?: Maybe<CanvasWhereInput>;
  canvas_ids_some?: Maybe<CanvasWhereInput>;
  canvas_ids_none?: Maybe<CanvasWhereInput>;
  strategy_pattern_ids_every?: Maybe<StrategyPatternWhereInput>;
  strategy_pattern_ids_some?: Maybe<StrategyPatternWhereInput>;
  strategy_pattern_ids_none?: Maybe<StrategyPatternWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StrategyWhereInput[] | StrategyWhereInput>;
  OR?: Maybe<StrategyWhereInput[] | StrategyWhereInput>;
  NOT?: Maybe<StrategyWhereInput[] | StrategyWhereInput>;
}

export interface StrategyPatternWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  strategy_id?: Maybe<StrategyWhereInput>;
  pattern_id?: Maybe<PatternWhereInput>;
  weight?: Maybe<Int>;
  weight_not?: Maybe<Int>;
  weight_in?: Maybe<Int[] | Int>;
  weight_not_in?: Maybe<Int[] | Int>;
  weight_lt?: Maybe<Int>;
  weight_lte?: Maybe<Int>;
  weight_gt?: Maybe<Int>;
  weight_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StrategyPatternWhereInput[] | StrategyPatternWhereInput>;
  OR?: Maybe<StrategyPatternWhereInput[] | StrategyPatternWhereInput>;
  NOT?: Maybe<StrategyPatternWhereInput[] | StrategyPatternWhereInput>;
}

export interface PatternWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  canvas_ids_every?: Maybe<CanvasWhereInput>;
  canvas_ids_some?: Maybe<CanvasWhereInput>;
  canvas_ids_none?: Maybe<CanvasWhereInput>;
  table_id?: Maybe<TableWhereInput>;
  company_ids_every?: Maybe<CompanyWhereInput>;
  company_ids_some?: Maybe<CompanyWhereInput>;
  company_ids_none?: Maybe<CompanyWhereInput>;
  strategy_pattern_ids_every?: Maybe<StrategyPatternWhereInput>;
  strategy_pattern_ids_some?: Maybe<StrategyPatternWhereInput>;
  strategy_pattern_ids_none?: Maybe<StrategyPatternWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  actorWeight_not?: Maybe<Int>;
  actorWeight_in?: Maybe<Int[] | Int>;
  actorWeight_not_in?: Maybe<Int[] | Int>;
  actorWeight_lt?: Maybe<Int>;
  actorWeight_lte?: Maybe<Int>;
  actorWeight_gt?: Maybe<Int>;
  actorWeight_gte?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valuePropositionWeight_not?: Maybe<Int>;
  valuePropositionWeight_in?: Maybe<Int[] | Int>;
  valuePropositionWeight_not_in?: Maybe<Int[] | Int>;
  valuePropositionWeight_lt?: Maybe<Int>;
  valuePropositionWeight_lte?: Maybe<Int>;
  valuePropositionWeight_gt?: Maybe<Int>;
  valuePropositionWeight_gte?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueCreationWeight_not?: Maybe<Int>;
  valueCreationWeight_in?: Maybe<Int[] | Int>;
  valueCreationWeight_not_in?: Maybe<Int[] | Int>;
  valueCreationWeight_lt?: Maybe<Int>;
  valueCreationWeight_lte?: Maybe<Int>;
  valueCreationWeight_gt?: Maybe<Int>;
  valueCreationWeight_gte?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  valueDeliveryWeight_not?: Maybe<Int>;
  valueDeliveryWeight_in?: Maybe<Int[] | Int>;
  valueDeliveryWeight_not_in?: Maybe<Int[] | Int>;
  valueDeliveryWeight_lt?: Maybe<Int>;
  valueDeliveryWeight_lte?: Maybe<Int>;
  valueDeliveryWeight_gt?: Maybe<Int>;
  valueDeliveryWeight_gte?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  revenueWeight_not?: Maybe<Int>;
  revenueWeight_in?: Maybe<Int[] | Int>;
  revenueWeight_not_in?: Maybe<Int[] | Int>;
  revenueWeight_lt?: Maybe<Int>;
  revenueWeight_lte?: Maybe<Int>;
  revenueWeight_gt?: Maybe<Int>;
  revenueWeight_gte?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  expenseWeight_not?: Maybe<Int>;
  expenseWeight_in?: Maybe<Int[] | Int>;
  expenseWeight_not_in?: Maybe<Int[] | Int>;
  expenseWeight_lt?: Maybe<Int>;
  expenseWeight_lte?: Maybe<Int>;
  expenseWeight_gt?: Maybe<Int>;
  expenseWeight_gte?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  networkEffectWeight_not?: Maybe<Int>;
  networkEffectWeight_in?: Maybe<Int[] | Int>;
  networkEffectWeight_not_in?: Maybe<Int[] | Int>;
  networkEffectWeight_lt?: Maybe<Int>;
  networkEffectWeight_lte?: Maybe<Int>;
  networkEffectWeight_gt?: Maybe<Int>;
  networkEffectWeight_gte?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  regulatoryWeight_not?: Maybe<Int>;
  regulatoryWeight_in?: Maybe<Int[] | Int>;
  regulatoryWeight_not_in?: Maybe<Int[] | Int>;
  regulatoryWeight_lt?: Maybe<Int>;
  regulatoryWeight_lte?: Maybe<Int>;
  regulatoryWeight_gt?: Maybe<Int>;
  regulatoryWeight_gte?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  technicalInfrastructureWeight_not?: Maybe<Int>;
  technicalInfrastructureWeight_in?: Maybe<Int[] | Int>;
  technicalInfrastructureWeight_not_in?: Maybe<Int[] | Int>;
  technicalInfrastructureWeight_lt?: Maybe<Int>;
  technicalInfrastructureWeight_lte?: Maybe<Int>;
  technicalInfrastructureWeight_gt?: Maybe<Int>;
  technicalInfrastructureWeight_gte?: Maybe<Int>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PatternWhereInput[] | PatternWhereInput>;
  OR?: Maybe<PatternWhereInput[] | PatternWhereInput>;
  NOT?: Maybe<PatternWhereInput[] | PatternWhereInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  pattern_ids_every?: Maybe<PatternWhereInput>;
  pattern_ids_some?: Maybe<PatternWhereInput>;
  pattern_ids_none?: Maybe<PatternWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface ValuePropositionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ValuePropositionWhereInput[] | ValuePropositionWhereInput>;
  OR?: Maybe<ValuePropositionWhereInput[] | ValuePropositionWhereInput>;
  NOT?: Maybe<ValuePropositionWhereInput[] | ValuePropositionWhereInput>;
}

export interface ValueCreationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ValueCreationWhereInput[] | ValueCreationWhereInput>;
  OR?: Maybe<ValueCreationWhereInput[] | ValueCreationWhereInput>;
  NOT?: Maybe<ValueCreationWhereInput[] | ValueCreationWhereInput>;
}

export interface ValueDeliveryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ValueDeliveryWhereInput[] | ValueDeliveryWhereInput>;
  OR?: Maybe<ValueDeliveryWhereInput[] | ValueDeliveryWhereInput>;
  NOT?: Maybe<ValueDeliveryWhereInput[] | ValueDeliveryWhereInput>;
}

export interface RevenueWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RevenueWhereInput[] | RevenueWhereInput>;
  OR?: Maybe<RevenueWhereInput[] | RevenueWhereInput>;
  NOT?: Maybe<RevenueWhereInput[] | RevenueWhereInput>;
}

export interface ExpenseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
  OR?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
  NOT?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
}

export interface NetworkEffectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NetworkEffectWhereInput[] | NetworkEffectWhereInput>;
  OR?: Maybe<NetworkEffectWhereInput[] | NetworkEffectWhereInput>;
  NOT?: Maybe<NetworkEffectWhereInput[] | NetworkEffectWhereInput>;
}

export interface TechnicalInfrastructureWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    TechnicalInfrastructureWhereInput[] | TechnicalInfrastructureWhereInput
  >;
  OR?: Maybe<
    TechnicalInfrastructureWhereInput[] | TechnicalInfrastructureWhereInput
  >;
  NOT?: Maybe<
    TechnicalInfrastructureWhereInput[] | TechnicalInfrastructureWhereInput
  >;
}

export interface RegulatoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table_ids_every?: Maybe<TableWhereInput>;
  table_ids_some?: Maybe<TableWhereInput>;
  table_ids_none?: Maybe<TableWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  updatedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RegulatoryWhereInput[] | RegulatoryWhereInput>;
  OR?: Maybe<RegulatoryWhereInput[] | RegulatoryWhereInput>;
  NOT?: Maybe<RegulatoryWhereInput[] | RegulatoryWhereInput>;
}

export type CanvasWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExpenseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NetworkEffectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PatternWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RegulatoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RevenueWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type StrategyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type StrategyPatternWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TableWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TechnicalInfrastructureWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type ValueCreationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ValueDeliveryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ValuePropositionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ActorCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutActor_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutActor_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutActor_entry_idsInput[]
    | TableCreateWithoutActor_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutActor_entry_idsInput {
  id?: Maybe<ID_Input>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface ValuePropositionCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | ValuePropositionCreateWithoutTable_idsInput[]
    | ValuePropositionCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
}

export interface ValuePropositionCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  project_ids?: Maybe<ProjectCreateManyWithoutUser_idInput>;
  firstName: String;
  lastName: String;
  email: String;
  role?: Maybe<Role>;
  password: String;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserCreateOneWithoutUpdatedByInput>;
}

export interface ProjectCreateManyWithoutUser_idInput {
  create?: Maybe<
    ProjectCreateWithoutUser_idInput[] | ProjectCreateWithoutUser_idInput
  >;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
}

export interface ProjectCreateWithoutUser_idInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutProject_idInput>;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CanvasCreateManyWithoutProject_idInput {
  create?: Maybe<
    CanvasCreateWithoutProject_idInput[] | CanvasCreateWithoutProject_idInput
  >;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
}

export interface CanvasCreateWithoutProject_idInput {
  id?: Maybe<ID_Input>;
  strategy_id?: Maybe<StrategyCreateOneWithoutCanvas_idsInput>;
  pattern_ids?: Maybe<PatternCreateManyWithoutCanvas_idsInput>;
  table_id: TableCreateOneInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface StrategyCreateOneWithoutCanvas_idsInput {
  create?: Maybe<StrategyCreateWithoutCanvas_idsInput>;
  connect?: Maybe<StrategyWhereUniqueInput>;
}

export interface StrategyCreateWithoutCanvas_idsInput {
  id?: Maybe<ID_Input>;
  strategy_pattern_ids?: Maybe<
    StrategyPatternCreateManyWithoutStrategy_idInput
  >;
  name: String;
  description?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface StrategyPatternCreateManyWithoutStrategy_idInput {
  create?: Maybe<
    | StrategyPatternCreateWithoutStrategy_idInput[]
    | StrategyPatternCreateWithoutStrategy_idInput
  >;
  connect?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
}

export interface StrategyPatternCreateWithoutStrategy_idInput {
  id?: Maybe<ID_Input>;
  pattern_id: PatternCreateOneWithoutStrategy_pattern_idsInput;
  weight: Int;
}

export interface PatternCreateOneWithoutStrategy_pattern_idsInput {
  create?: Maybe<PatternCreateWithoutStrategy_pattern_idsInput>;
  connect?: Maybe<PatternWhereUniqueInput>;
}

export interface PatternCreateWithoutStrategy_pattern_idsInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutPattern_idsInput>;
  table_id: TableCreateOneInput;
  company_ids?: Maybe<CompanyCreateManyWithoutPattern_idsInput>;
  name: String;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CanvasCreateManyWithoutPattern_idsInput {
  create?: Maybe<
    CanvasCreateWithoutPattern_idsInput[] | CanvasCreateWithoutPattern_idsInput
  >;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
}

export interface CanvasCreateWithoutPattern_idsInput {
  id?: Maybe<ID_Input>;
  project_id: ProjectCreateOneWithoutCanvas_idsInput;
  strategy_id?: Maybe<StrategyCreateOneWithoutCanvas_idsInput>;
  table_id: TableCreateOneInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ProjectCreateOneWithoutCanvas_idsInput {
  create?: Maybe<ProjectCreateWithoutCanvas_idsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface ProjectCreateWithoutCanvas_idsInput {
  id?: Maybe<ID_Input>;
  user_id: UserCreateOneWithoutProject_idsInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface UserCreateOneWithoutProject_idsInput {
  create?: Maybe<UserCreateWithoutProject_idsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutProject_idsInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  email: String;
  role?: Maybe<Role>;
  password: String;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserCreateOneWithoutUpdatedByInput>;
}

export interface UserCreateOneWithoutUpdatedByInput {
  create?: Maybe<UserCreateWithoutUpdatedByInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutUpdatedByInput {
  id?: Maybe<ID_Input>;
  project_ids?: Maybe<ProjectCreateManyWithoutUser_idInput>;
  firstName: String;
  lastName: String;
  email: String;
  role?: Maybe<Role>;
  password: String;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
}

export interface TableCreateOneInput {
  create?: Maybe<TableCreateInput>;
  connect?: Maybe<TableWhereUniqueInput>;
}

export interface TableCreateInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface ActorCreateManyWithoutTable_idsInput {
  create?: Maybe<
    ActorCreateWithoutTable_idsInput[] | ActorCreateWithoutTable_idsInput
  >;
  connect?: Maybe<ActorWhereUniqueInput[] | ActorWhereUniqueInput>;
}

export interface ActorCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ValueCreationCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | ValueCreationCreateWithoutTable_idsInput[]
    | ValueCreationCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    ValueCreationWhereUniqueInput[] | ValueCreationWhereUniqueInput
  >;
}

export interface ValueCreationCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ValueDeliveryCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | ValueDeliveryCreateWithoutTable_idsInput[]
    | ValueDeliveryCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    ValueDeliveryWhereUniqueInput[] | ValueDeliveryWhereUniqueInput
  >;
}

export interface ValueDeliveryCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface RevenueCreateManyWithoutTable_idsInput {
  create?: Maybe<
    RevenueCreateWithoutTable_idsInput[] | RevenueCreateWithoutTable_idsInput
  >;
  connect?: Maybe<RevenueWhereUniqueInput[] | RevenueWhereUniqueInput>;
}

export interface RevenueCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ExpenseCreateManyWithoutTable_idsInput {
  create?: Maybe<
    ExpenseCreateWithoutTable_idsInput[] | ExpenseCreateWithoutTable_idsInput
  >;
  connect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
}

export interface ExpenseCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface NetworkEffectCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | NetworkEffectCreateWithoutTable_idsInput[]
    | NetworkEffectCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    NetworkEffectWhereUniqueInput[] | NetworkEffectWhereUniqueInput
  >;
}

export interface NetworkEffectCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TechnicalInfrastructureCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | TechnicalInfrastructureCreateWithoutTable_idsInput[]
    | TechnicalInfrastructureCreateWithoutTable_idsInput
  >;
  connect?: Maybe<
    | TechnicalInfrastructureWhereUniqueInput[]
    | TechnicalInfrastructureWhereUniqueInput
  >;
}

export interface TechnicalInfrastructureCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface RegulatoryCreateManyWithoutTable_idsInput {
  create?: Maybe<
    | RegulatoryCreateWithoutTable_idsInput[]
    | RegulatoryCreateWithoutTable_idsInput
  >;
  connect?: Maybe<RegulatoryWhereUniqueInput[] | RegulatoryWhereUniqueInput>;
}

export interface RegulatoryCreateWithoutTable_idsInput {
  id?: Maybe<ID_Input>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CompanyCreateManyWithoutPattern_idsInput {
  create?: Maybe<
    | CompanyCreateWithoutPattern_idsInput[]
    | CompanyCreateWithoutPattern_idsInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutPattern_idsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
}

export interface PatternCreateManyWithoutCanvas_idsInput {
  create?: Maybe<
    PatternCreateWithoutCanvas_idsInput[] | PatternCreateWithoutCanvas_idsInput
  >;
  connect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
}

export interface PatternCreateWithoutCanvas_idsInput {
  id?: Maybe<ID_Input>;
  table_id: TableCreateOneInput;
  company_ids?: Maybe<CompanyCreateManyWithoutPattern_idsInput>;
  strategy_pattern_ids?: Maybe<StrategyPatternCreateManyWithoutPattern_idInput>;
  name: String;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface StrategyPatternCreateManyWithoutPattern_idInput {
  create?: Maybe<
    | StrategyPatternCreateWithoutPattern_idInput[]
    | StrategyPatternCreateWithoutPattern_idInput
  >;
  connect?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
}

export interface StrategyPatternCreateWithoutPattern_idInput {
  id?: Maybe<ID_Input>;
  strategy_id: StrategyCreateOneWithoutStrategy_pattern_idsInput;
  weight: Int;
}

export interface StrategyCreateOneWithoutStrategy_pattern_idsInput {
  create?: Maybe<StrategyCreateWithoutStrategy_pattern_idsInput>;
  connect?: Maybe<StrategyWhereUniqueInput>;
}

export interface StrategyCreateWithoutStrategy_pattern_idsInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutStrategy_idInput>;
  name: String;
  description?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CanvasCreateManyWithoutStrategy_idInput {
  create?: Maybe<
    CanvasCreateWithoutStrategy_idInput[] | CanvasCreateWithoutStrategy_idInput
  >;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
}

export interface CanvasCreateWithoutStrategy_idInput {
  id?: Maybe<ID_Input>;
  project_id: ProjectCreateOneWithoutCanvas_idsInput;
  pattern_ids?: Maybe<PatternCreateManyWithoutCanvas_idsInput>;
  table_id: TableCreateOneInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ActorUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutActor_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutActor_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutActor_entry_idsInput[]
    | TableCreateWithoutActor_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutActor_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutActor_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutActor_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutActor_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutActor_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutActor_entry_idsDataInput;
}

export interface TableUpdateWithoutActor_entry_idsDataInput {
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface ValuePropositionUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | ValuePropositionCreateWithoutTable_idsInput[]
    | ValuePropositionCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
  connect?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
  set?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
  disconnect?: Maybe<
    ValuePropositionWhereUniqueInput[] | ValuePropositionWhereUniqueInput
  >;
  update?: Maybe<
    | ValuePropositionUpdateWithWhereUniqueWithoutTable_idsInput[]
    | ValuePropositionUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | ValuePropositionUpsertWithWhereUniqueWithoutTable_idsInput[]
    | ValuePropositionUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    ValuePropositionScalarWhereInput[] | ValuePropositionScalarWhereInput
  >;
  updateMany?: Maybe<
    | ValuePropositionUpdateManyWithWhereNestedInput[]
    | ValuePropositionUpdateManyWithWhereNestedInput
  >;
}

export interface ValuePropositionUpdateWithWhereUniqueWithoutTable_idsInput {
  where: ValuePropositionWhereUniqueInput;
  data: ValuePropositionUpdateWithoutTable_idsDataInput;
}

export interface ValuePropositionUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  project_ids?: Maybe<ProjectUpdateManyWithoutUser_idInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserUpdateOneWithoutUpdatedByInput>;
}

export interface ProjectUpdateManyWithoutUser_idInput {
  create?: Maybe<
    ProjectCreateWithoutUser_idInput[] | ProjectCreateWithoutUser_idInput
  >;
  delete?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  set?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  disconnect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  update?: Maybe<
    | ProjectUpdateWithWhereUniqueWithoutUser_idInput[]
    | ProjectUpdateWithWhereUniqueWithoutUser_idInput
  >;
  upsert?: Maybe<
    | ProjectUpsertWithWhereUniqueWithoutUser_idInput[]
    | ProjectUpsertWithWhereUniqueWithoutUser_idInput
  >;
  deleteMany?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  updateMany?: Maybe<
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectUpdateWithWhereUniqueWithoutUser_idInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutUser_idDataInput;
}

export interface ProjectUpdateWithoutUser_idDataInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutProject_idInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CanvasUpdateManyWithoutProject_idInput {
  create?: Maybe<
    CanvasCreateWithoutProject_idInput[] | CanvasCreateWithoutProject_idInput
  >;
  delete?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  set?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  disconnect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  update?: Maybe<
    | CanvasUpdateWithWhereUniqueWithoutProject_idInput[]
    | CanvasUpdateWithWhereUniqueWithoutProject_idInput
  >;
  upsert?: Maybe<
    | CanvasUpsertWithWhereUniqueWithoutProject_idInput[]
    | CanvasUpsertWithWhereUniqueWithoutProject_idInput
  >;
  deleteMany?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  updateMany?: Maybe<
    | CanvasUpdateManyWithWhereNestedInput[]
    | CanvasUpdateManyWithWhereNestedInput
  >;
}

export interface CanvasUpdateWithWhereUniqueWithoutProject_idInput {
  where: CanvasWhereUniqueInput;
  data: CanvasUpdateWithoutProject_idDataInput;
}

export interface CanvasUpdateWithoutProject_idDataInput {
  strategy_id?: Maybe<StrategyUpdateOneWithoutCanvas_idsInput>;
  pattern_ids?: Maybe<PatternUpdateManyWithoutCanvas_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface StrategyUpdateOneWithoutCanvas_idsInput {
  create?: Maybe<StrategyCreateWithoutCanvas_idsInput>;
  update?: Maybe<StrategyUpdateWithoutCanvas_idsDataInput>;
  upsert?: Maybe<StrategyUpsertWithoutCanvas_idsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StrategyWhereUniqueInput>;
}

export interface StrategyUpdateWithoutCanvas_idsDataInput {
  strategy_pattern_ids?: Maybe<
    StrategyPatternUpdateManyWithoutStrategy_idInput
  >;
  name?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface StrategyPatternUpdateManyWithoutStrategy_idInput {
  create?: Maybe<
    | StrategyPatternCreateWithoutStrategy_idInput[]
    | StrategyPatternCreateWithoutStrategy_idInput
  >;
  delete?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
  connect?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
  set?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
  disconnect?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
  update?: Maybe<
    | StrategyPatternUpdateWithWhereUniqueWithoutStrategy_idInput[]
    | StrategyPatternUpdateWithWhereUniqueWithoutStrategy_idInput
  >;
  upsert?: Maybe<
    | StrategyPatternUpsertWithWhereUniqueWithoutStrategy_idInput[]
    | StrategyPatternUpsertWithWhereUniqueWithoutStrategy_idInput
  >;
  deleteMany?: Maybe<
    StrategyPatternScalarWhereInput[] | StrategyPatternScalarWhereInput
  >;
  updateMany?: Maybe<
    | StrategyPatternUpdateManyWithWhereNestedInput[]
    | StrategyPatternUpdateManyWithWhereNestedInput
  >;
}

export interface StrategyPatternUpdateWithWhereUniqueWithoutStrategy_idInput {
  where: StrategyPatternWhereUniqueInput;
  data: StrategyPatternUpdateWithoutStrategy_idDataInput;
}

export interface StrategyPatternUpdateWithoutStrategy_idDataInput {
  pattern_id?: Maybe<PatternUpdateOneRequiredWithoutStrategy_pattern_idsInput>;
  weight?: Maybe<Int>;
}

export interface PatternUpdateOneRequiredWithoutStrategy_pattern_idsInput {
  create?: Maybe<PatternCreateWithoutStrategy_pattern_idsInput>;
  update?: Maybe<PatternUpdateWithoutStrategy_pattern_idsDataInput>;
  upsert?: Maybe<PatternUpsertWithoutStrategy_pattern_idsInput>;
  connect?: Maybe<PatternWhereUniqueInput>;
}

export interface PatternUpdateWithoutStrategy_pattern_idsDataInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutPattern_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  company_ids?: Maybe<CompanyUpdateManyWithoutPattern_idsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CanvasUpdateManyWithoutPattern_idsInput {
  create?: Maybe<
    CanvasCreateWithoutPattern_idsInput[] | CanvasCreateWithoutPattern_idsInput
  >;
  delete?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  set?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  disconnect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  update?: Maybe<
    | CanvasUpdateWithWhereUniqueWithoutPattern_idsInput[]
    | CanvasUpdateWithWhereUniqueWithoutPattern_idsInput
  >;
  upsert?: Maybe<
    | CanvasUpsertWithWhereUniqueWithoutPattern_idsInput[]
    | CanvasUpsertWithWhereUniqueWithoutPattern_idsInput
  >;
  deleteMany?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  updateMany?: Maybe<
    | CanvasUpdateManyWithWhereNestedInput[]
    | CanvasUpdateManyWithWhereNestedInput
  >;
}

export interface CanvasUpdateWithWhereUniqueWithoutPattern_idsInput {
  where: CanvasWhereUniqueInput;
  data: CanvasUpdateWithoutPattern_idsDataInput;
}

export interface CanvasUpdateWithoutPattern_idsDataInput {
  project_id?: Maybe<ProjectUpdateOneRequiredWithoutCanvas_idsInput>;
  strategy_id?: Maybe<StrategyUpdateOneWithoutCanvas_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ProjectUpdateOneRequiredWithoutCanvas_idsInput {
  create?: Maybe<ProjectCreateWithoutCanvas_idsInput>;
  update?: Maybe<ProjectUpdateWithoutCanvas_idsDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutCanvas_idsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface ProjectUpdateWithoutCanvas_idsDataInput {
  user_id?: Maybe<UserUpdateOneRequiredWithoutProject_idsInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredWithoutProject_idsInput {
  create?: Maybe<UserCreateWithoutProject_idsInput>;
  update?: Maybe<UserUpdateWithoutProject_idsDataInput>;
  upsert?: Maybe<UserUpsertWithoutProject_idsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutProject_idsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserUpdateOneWithoutUpdatedByInput>;
}

export interface UserUpdateOneWithoutUpdatedByInput {
  create?: Maybe<UserCreateWithoutUpdatedByInput>;
  update?: Maybe<UserUpdateWithoutUpdatedByDataInput>;
  upsert?: Maybe<UserUpsertWithoutUpdatedByInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutUpdatedByDataInput {
  project_ids?: Maybe<ProjectUpdateManyWithoutUser_idInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
}

export interface UserUpsertWithoutUpdatedByInput {
  update: UserUpdateWithoutUpdatedByDataInput;
  create: UserCreateWithoutUpdatedByInput;
}

export interface UserUpsertWithoutProject_idsInput {
  update: UserUpdateWithoutProject_idsDataInput;
  create: UserCreateWithoutProject_idsInput;
}

export interface ProjectUpsertWithoutCanvas_idsInput {
  update: ProjectUpdateWithoutCanvas_idsDataInput;
  create: ProjectCreateWithoutCanvas_idsInput;
}

export interface TableUpdateOneRequiredInput {
  create?: Maybe<TableCreateInput>;
  update?: Maybe<TableUpdateDataInput>;
  upsert?: Maybe<TableUpsertNestedInput>;
  connect?: Maybe<TableWhereUniqueInput>;
}

export interface TableUpdateDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface ActorUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    ActorCreateWithoutTable_idsInput[] | ActorCreateWithoutTable_idsInput
  >;
  delete?: Maybe<ActorWhereUniqueInput[] | ActorWhereUniqueInput>;
  connect?: Maybe<ActorWhereUniqueInput[] | ActorWhereUniqueInput>;
  set?: Maybe<ActorWhereUniqueInput[] | ActorWhereUniqueInput>;
  disconnect?: Maybe<ActorWhereUniqueInput[] | ActorWhereUniqueInput>;
  update?: Maybe<
    | ActorUpdateWithWhereUniqueWithoutTable_idsInput[]
    | ActorUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | ActorUpsertWithWhereUniqueWithoutTable_idsInput[]
    | ActorUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<ActorScalarWhereInput[] | ActorScalarWhereInput>;
  updateMany?: Maybe<
    ActorUpdateManyWithWhereNestedInput[] | ActorUpdateManyWithWhereNestedInput
  >;
}

export interface ActorUpdateWithWhereUniqueWithoutTable_idsInput {
  where: ActorWhereUniqueInput;
  data: ActorUpdateWithoutTable_idsDataInput;
}

export interface ActorUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ActorUpsertWithWhereUniqueWithoutTable_idsInput {
  where: ActorWhereUniqueInput;
  update: ActorUpdateWithoutTable_idsDataInput;
  create: ActorCreateWithoutTable_idsInput;
}

export interface ActorScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ActorScalarWhereInput[] | ActorScalarWhereInput>;
  OR?: Maybe<ActorScalarWhereInput[] | ActorScalarWhereInput>;
  NOT?: Maybe<ActorScalarWhereInput[] | ActorScalarWhereInput>;
}

export interface ActorUpdateManyWithWhereNestedInput {
  where: ActorScalarWhereInput;
  data: ActorUpdateManyDataInput;
}

export interface ActorUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface ValueCreationUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | ValueCreationCreateWithoutTable_idsInput[]
    | ValueCreationCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    ValueCreationWhereUniqueInput[] | ValueCreationWhereUniqueInput
  >;
  connect?: Maybe<
    ValueCreationWhereUniqueInput[] | ValueCreationWhereUniqueInput
  >;
  set?: Maybe<ValueCreationWhereUniqueInput[] | ValueCreationWhereUniqueInput>;
  disconnect?: Maybe<
    ValueCreationWhereUniqueInput[] | ValueCreationWhereUniqueInput
  >;
  update?: Maybe<
    | ValueCreationUpdateWithWhereUniqueWithoutTable_idsInput[]
    | ValueCreationUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | ValueCreationUpsertWithWhereUniqueWithoutTable_idsInput[]
    | ValueCreationUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    ValueCreationScalarWhereInput[] | ValueCreationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ValueCreationUpdateManyWithWhereNestedInput[]
    | ValueCreationUpdateManyWithWhereNestedInput
  >;
}

export interface ValueCreationUpdateWithWhereUniqueWithoutTable_idsInput {
  where: ValueCreationWhereUniqueInput;
  data: ValueCreationUpdateWithoutTable_idsDataInput;
}

export interface ValueCreationUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ValueCreationUpsertWithWhereUniqueWithoutTable_idsInput {
  where: ValueCreationWhereUniqueInput;
  update: ValueCreationUpdateWithoutTable_idsDataInput;
  create: ValueCreationCreateWithoutTable_idsInput;
}

export interface ValueCreationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ValueCreationScalarWhereInput[] | ValueCreationScalarWhereInput>;
  OR?: Maybe<ValueCreationScalarWhereInput[] | ValueCreationScalarWhereInput>;
  NOT?: Maybe<ValueCreationScalarWhereInput[] | ValueCreationScalarWhereInput>;
}

export interface ValueCreationUpdateManyWithWhereNestedInput {
  where: ValueCreationScalarWhereInput;
  data: ValueCreationUpdateManyDataInput;
}

export interface ValueCreationUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface ValueDeliveryUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | ValueDeliveryCreateWithoutTable_idsInput[]
    | ValueDeliveryCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    ValueDeliveryWhereUniqueInput[] | ValueDeliveryWhereUniqueInput
  >;
  connect?: Maybe<
    ValueDeliveryWhereUniqueInput[] | ValueDeliveryWhereUniqueInput
  >;
  set?: Maybe<ValueDeliveryWhereUniqueInput[] | ValueDeliveryWhereUniqueInput>;
  disconnect?: Maybe<
    ValueDeliveryWhereUniqueInput[] | ValueDeliveryWhereUniqueInput
  >;
  update?: Maybe<
    | ValueDeliveryUpdateWithWhereUniqueWithoutTable_idsInput[]
    | ValueDeliveryUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | ValueDeliveryUpsertWithWhereUniqueWithoutTable_idsInput[]
    | ValueDeliveryUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    ValueDeliveryScalarWhereInput[] | ValueDeliveryScalarWhereInput
  >;
  updateMany?: Maybe<
    | ValueDeliveryUpdateManyWithWhereNestedInput[]
    | ValueDeliveryUpdateManyWithWhereNestedInput
  >;
}

export interface ValueDeliveryUpdateWithWhereUniqueWithoutTable_idsInput {
  where: ValueDeliveryWhereUniqueInput;
  data: ValueDeliveryUpdateWithoutTable_idsDataInput;
}

export interface ValueDeliveryUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ValueDeliveryUpsertWithWhereUniqueWithoutTable_idsInput {
  where: ValueDeliveryWhereUniqueInput;
  update: ValueDeliveryUpdateWithoutTable_idsDataInput;
  create: ValueDeliveryCreateWithoutTable_idsInput;
}

export interface ValueDeliveryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ValueDeliveryScalarWhereInput[] | ValueDeliveryScalarWhereInput>;
  OR?: Maybe<ValueDeliveryScalarWhereInput[] | ValueDeliveryScalarWhereInput>;
  NOT?: Maybe<ValueDeliveryScalarWhereInput[] | ValueDeliveryScalarWhereInput>;
}

export interface ValueDeliveryUpdateManyWithWhereNestedInput {
  where: ValueDeliveryScalarWhereInput;
  data: ValueDeliveryUpdateManyDataInput;
}

export interface ValueDeliveryUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface RevenueUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    RevenueCreateWithoutTable_idsInput[] | RevenueCreateWithoutTable_idsInput
  >;
  delete?: Maybe<RevenueWhereUniqueInput[] | RevenueWhereUniqueInput>;
  connect?: Maybe<RevenueWhereUniqueInput[] | RevenueWhereUniqueInput>;
  set?: Maybe<RevenueWhereUniqueInput[] | RevenueWhereUniqueInput>;
  disconnect?: Maybe<RevenueWhereUniqueInput[] | RevenueWhereUniqueInput>;
  update?: Maybe<
    | RevenueUpdateWithWhereUniqueWithoutTable_idsInput[]
    | RevenueUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | RevenueUpsertWithWhereUniqueWithoutTable_idsInput[]
    | RevenueUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<RevenueScalarWhereInput[] | RevenueScalarWhereInput>;
  updateMany?: Maybe<
    | RevenueUpdateManyWithWhereNestedInput[]
    | RevenueUpdateManyWithWhereNestedInput
  >;
}

export interface RevenueUpdateWithWhereUniqueWithoutTable_idsInput {
  where: RevenueWhereUniqueInput;
  data: RevenueUpdateWithoutTable_idsDataInput;
}

export interface RevenueUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface RevenueUpsertWithWhereUniqueWithoutTable_idsInput {
  where: RevenueWhereUniqueInput;
  update: RevenueUpdateWithoutTable_idsDataInput;
  create: RevenueCreateWithoutTable_idsInput;
}

export interface RevenueScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RevenueScalarWhereInput[] | RevenueScalarWhereInput>;
  OR?: Maybe<RevenueScalarWhereInput[] | RevenueScalarWhereInput>;
  NOT?: Maybe<RevenueScalarWhereInput[] | RevenueScalarWhereInput>;
}

export interface RevenueUpdateManyWithWhereNestedInput {
  where: RevenueScalarWhereInput;
  data: RevenueUpdateManyDataInput;
}

export interface RevenueUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface ExpenseUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    ExpenseCreateWithoutTable_idsInput[] | ExpenseCreateWithoutTable_idsInput
  >;
  delete?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  connect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  set?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  disconnect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  update?: Maybe<
    | ExpenseUpdateWithWhereUniqueWithoutTable_idsInput[]
    | ExpenseUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | ExpenseUpsertWithWhereUniqueWithoutTable_idsInput[]
    | ExpenseUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  updateMany?: Maybe<
    | ExpenseUpdateManyWithWhereNestedInput[]
    | ExpenseUpdateManyWithWhereNestedInput
  >;
}

export interface ExpenseUpdateWithWhereUniqueWithoutTable_idsInput {
  where: ExpenseWhereUniqueInput;
  data: ExpenseUpdateWithoutTable_idsDataInput;
}

export interface ExpenseUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ExpenseUpsertWithWhereUniqueWithoutTable_idsInput {
  where: ExpenseWhereUniqueInput;
  update: ExpenseUpdateWithoutTable_idsDataInput;
  create: ExpenseCreateWithoutTable_idsInput;
}

export interface ExpenseScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  OR?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  NOT?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
}

export interface ExpenseUpdateManyWithWhereNestedInput {
  where: ExpenseScalarWhereInput;
  data: ExpenseUpdateManyDataInput;
}

export interface ExpenseUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface NetworkEffectUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | NetworkEffectCreateWithoutTable_idsInput[]
    | NetworkEffectCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    NetworkEffectWhereUniqueInput[] | NetworkEffectWhereUniqueInput
  >;
  connect?: Maybe<
    NetworkEffectWhereUniqueInput[] | NetworkEffectWhereUniqueInput
  >;
  set?: Maybe<NetworkEffectWhereUniqueInput[] | NetworkEffectWhereUniqueInput>;
  disconnect?: Maybe<
    NetworkEffectWhereUniqueInput[] | NetworkEffectWhereUniqueInput
  >;
  update?: Maybe<
    | NetworkEffectUpdateWithWhereUniqueWithoutTable_idsInput[]
    | NetworkEffectUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | NetworkEffectUpsertWithWhereUniqueWithoutTable_idsInput[]
    | NetworkEffectUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    NetworkEffectScalarWhereInput[] | NetworkEffectScalarWhereInput
  >;
  updateMany?: Maybe<
    | NetworkEffectUpdateManyWithWhereNestedInput[]
    | NetworkEffectUpdateManyWithWhereNestedInput
  >;
}

export interface NetworkEffectUpdateWithWhereUniqueWithoutTable_idsInput {
  where: NetworkEffectWhereUniqueInput;
  data: NetworkEffectUpdateWithoutTable_idsDataInput;
}

export interface NetworkEffectUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface NetworkEffectUpsertWithWhereUniqueWithoutTable_idsInput {
  where: NetworkEffectWhereUniqueInput;
  update: NetworkEffectUpdateWithoutTable_idsDataInput;
  create: NetworkEffectCreateWithoutTable_idsInput;
}

export interface NetworkEffectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NetworkEffectScalarWhereInput[] | NetworkEffectScalarWhereInput>;
  OR?: Maybe<NetworkEffectScalarWhereInput[] | NetworkEffectScalarWhereInput>;
  NOT?: Maybe<NetworkEffectScalarWhereInput[] | NetworkEffectScalarWhereInput>;
}

export interface NetworkEffectUpdateManyWithWhereNestedInput {
  where: NetworkEffectScalarWhereInput;
  data: NetworkEffectUpdateManyDataInput;
}

export interface NetworkEffectUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface TechnicalInfrastructureUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | TechnicalInfrastructureCreateWithoutTable_idsInput[]
    | TechnicalInfrastructureCreateWithoutTable_idsInput
  >;
  delete?: Maybe<
    | TechnicalInfrastructureWhereUniqueInput[]
    | TechnicalInfrastructureWhereUniqueInput
  >;
  connect?: Maybe<
    | TechnicalInfrastructureWhereUniqueInput[]
    | TechnicalInfrastructureWhereUniqueInput
  >;
  set?: Maybe<
    | TechnicalInfrastructureWhereUniqueInput[]
    | TechnicalInfrastructureWhereUniqueInput
  >;
  disconnect?: Maybe<
    | TechnicalInfrastructureWhereUniqueInput[]
    | TechnicalInfrastructureWhereUniqueInput
  >;
  update?: Maybe<
    | TechnicalInfrastructureUpdateWithWhereUniqueWithoutTable_idsInput[]
    | TechnicalInfrastructureUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | TechnicalInfrastructureUpsertWithWhereUniqueWithoutTable_idsInput[]
    | TechnicalInfrastructureUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<
    | TechnicalInfrastructureScalarWhereInput[]
    | TechnicalInfrastructureScalarWhereInput
  >;
  updateMany?: Maybe<
    | TechnicalInfrastructureUpdateManyWithWhereNestedInput[]
    | TechnicalInfrastructureUpdateManyWithWhereNestedInput
  >;
}

export interface TechnicalInfrastructureUpdateWithWhereUniqueWithoutTable_idsInput {
  where: TechnicalInfrastructureWhereUniqueInput;
  data: TechnicalInfrastructureUpdateWithoutTable_idsDataInput;
}

export interface TechnicalInfrastructureUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TechnicalInfrastructureUpsertWithWhereUniqueWithoutTable_idsInput {
  where: TechnicalInfrastructureWhereUniqueInput;
  update: TechnicalInfrastructureUpdateWithoutTable_idsDataInput;
  create: TechnicalInfrastructureCreateWithoutTable_idsInput;
}

export interface TechnicalInfrastructureScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | TechnicalInfrastructureScalarWhereInput[]
    | TechnicalInfrastructureScalarWhereInput
  >;
  OR?: Maybe<
    | TechnicalInfrastructureScalarWhereInput[]
    | TechnicalInfrastructureScalarWhereInput
  >;
  NOT?: Maybe<
    | TechnicalInfrastructureScalarWhereInput[]
    | TechnicalInfrastructureScalarWhereInput
  >;
}

export interface TechnicalInfrastructureUpdateManyWithWhereNestedInput {
  where: TechnicalInfrastructureScalarWhereInput;
  data: TechnicalInfrastructureUpdateManyDataInput;
}

export interface TechnicalInfrastructureUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface RegulatoryUpdateManyWithoutTable_idsInput {
  create?: Maybe<
    | RegulatoryCreateWithoutTable_idsInput[]
    | RegulatoryCreateWithoutTable_idsInput
  >;
  delete?: Maybe<RegulatoryWhereUniqueInput[] | RegulatoryWhereUniqueInput>;
  connect?: Maybe<RegulatoryWhereUniqueInput[] | RegulatoryWhereUniqueInput>;
  set?: Maybe<RegulatoryWhereUniqueInput[] | RegulatoryWhereUniqueInput>;
  disconnect?: Maybe<RegulatoryWhereUniqueInput[] | RegulatoryWhereUniqueInput>;
  update?: Maybe<
    | RegulatoryUpdateWithWhereUniqueWithoutTable_idsInput[]
    | RegulatoryUpdateWithWhereUniqueWithoutTable_idsInput
  >;
  upsert?: Maybe<
    | RegulatoryUpsertWithWhereUniqueWithoutTable_idsInput[]
    | RegulatoryUpsertWithWhereUniqueWithoutTable_idsInput
  >;
  deleteMany?: Maybe<RegulatoryScalarWhereInput[] | RegulatoryScalarWhereInput>;
  updateMany?: Maybe<
    | RegulatoryUpdateManyWithWhereNestedInput[]
    | RegulatoryUpdateManyWithWhereNestedInput
  >;
}

export interface RegulatoryUpdateWithWhereUniqueWithoutTable_idsInput {
  where: RegulatoryWhereUniqueInput;
  data: RegulatoryUpdateWithoutTable_idsDataInput;
}

export interface RegulatoryUpdateWithoutTable_idsDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface RegulatoryUpsertWithWhereUniqueWithoutTable_idsInput {
  where: RegulatoryWhereUniqueInput;
  update: RegulatoryUpdateWithoutTable_idsDataInput;
  create: RegulatoryCreateWithoutTable_idsInput;
}

export interface RegulatoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RegulatoryScalarWhereInput[] | RegulatoryScalarWhereInput>;
  OR?: Maybe<RegulatoryScalarWhereInput[] | RegulatoryScalarWhereInput>;
  NOT?: Maybe<RegulatoryScalarWhereInput[] | RegulatoryScalarWhereInput>;
}

export interface RegulatoryUpdateManyWithWhereNestedInput {
  where: RegulatoryScalarWhereInput;
  data: RegulatoryUpdateManyDataInput;
}

export interface RegulatoryUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface TableUpsertNestedInput {
  update: TableUpdateDataInput;
  create: TableCreateInput;
}

export interface CanvasUpsertWithWhereUniqueWithoutPattern_idsInput {
  where: CanvasWhereUniqueInput;
  update: CanvasUpdateWithoutPattern_idsDataInput;
  create: CanvasCreateWithoutPattern_idsInput;
}

export interface CanvasScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  OR?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  NOT?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
}

export interface CanvasUpdateManyWithWhereNestedInput {
  where: CanvasScalarWhereInput;
  data: CanvasUpdateManyDataInput;
}

export interface CanvasUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface CompanyUpdateManyWithoutPattern_idsInput {
  create?: Maybe<
    | CompanyCreateWithoutPattern_idsInput[]
    | CompanyCreateWithoutPattern_idsInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutPattern_idsInput[]
    | CompanyUpdateWithWhereUniqueWithoutPattern_idsInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutPattern_idsInput[]
    | CompanyUpsertWithWhereUniqueWithoutPattern_idsInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutPattern_idsInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutPattern_idsDataInput;
}

export interface CompanyUpdateWithoutPattern_idsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CompanyUpsertWithWhereUniqueWithoutPattern_idsInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutPattern_idsDataInput;
  create: CompanyCreateWithoutPattern_idsInput;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface CompanyUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface PatternUpsertWithoutStrategy_pattern_idsInput {
  update: PatternUpdateWithoutStrategy_pattern_idsDataInput;
  create: PatternCreateWithoutStrategy_pattern_idsInput;
}

export interface StrategyPatternUpsertWithWhereUniqueWithoutStrategy_idInput {
  where: StrategyPatternWhereUniqueInput;
  update: StrategyPatternUpdateWithoutStrategy_idDataInput;
  create: StrategyPatternCreateWithoutStrategy_idInput;
}

export interface StrategyPatternScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  weight?: Maybe<Int>;
  weight_not?: Maybe<Int>;
  weight_in?: Maybe<Int[] | Int>;
  weight_not_in?: Maybe<Int[] | Int>;
  weight_lt?: Maybe<Int>;
  weight_lte?: Maybe<Int>;
  weight_gt?: Maybe<Int>;
  weight_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    StrategyPatternScalarWhereInput[] | StrategyPatternScalarWhereInput
  >;
  OR?: Maybe<
    StrategyPatternScalarWhereInput[] | StrategyPatternScalarWhereInput
  >;
  NOT?: Maybe<
    StrategyPatternScalarWhereInput[] | StrategyPatternScalarWhereInput
  >;
}

export interface StrategyPatternUpdateManyWithWhereNestedInput {
  where: StrategyPatternScalarWhereInput;
  data: StrategyPatternUpdateManyDataInput;
}

export interface StrategyPatternUpdateManyDataInput {
  weight?: Maybe<Int>;
}

export interface StrategyUpsertWithoutCanvas_idsInput {
  update: StrategyUpdateWithoutCanvas_idsDataInput;
  create: StrategyCreateWithoutCanvas_idsInput;
}

export interface PatternUpdateManyWithoutCanvas_idsInput {
  create?: Maybe<
    PatternCreateWithoutCanvas_idsInput[] | PatternCreateWithoutCanvas_idsInput
  >;
  delete?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  connect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  set?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  disconnect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  update?: Maybe<
    | PatternUpdateWithWhereUniqueWithoutCanvas_idsInput[]
    | PatternUpdateWithWhereUniqueWithoutCanvas_idsInput
  >;
  upsert?: Maybe<
    | PatternUpsertWithWhereUniqueWithoutCanvas_idsInput[]
    | PatternUpsertWithWhereUniqueWithoutCanvas_idsInput
  >;
  deleteMany?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
  updateMany?: Maybe<
    | PatternUpdateManyWithWhereNestedInput[]
    | PatternUpdateManyWithWhereNestedInput
  >;
}

export interface PatternUpdateWithWhereUniqueWithoutCanvas_idsInput {
  where: PatternWhereUniqueInput;
  data: PatternUpdateWithoutCanvas_idsDataInput;
}

export interface PatternUpdateWithoutCanvas_idsDataInput {
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  company_ids?: Maybe<CompanyUpdateManyWithoutPattern_idsInput>;
  strategy_pattern_ids?: Maybe<StrategyPatternUpdateManyWithoutPattern_idInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface StrategyPatternUpdateManyWithoutPattern_idInput {
  create?: Maybe<
    | StrategyPatternCreateWithoutPattern_idInput[]
    | StrategyPatternCreateWithoutPattern_idInput
  >;
  delete?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
  connect?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
  set?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
  disconnect?: Maybe<
    StrategyPatternWhereUniqueInput[] | StrategyPatternWhereUniqueInput
  >;
  update?: Maybe<
    | StrategyPatternUpdateWithWhereUniqueWithoutPattern_idInput[]
    | StrategyPatternUpdateWithWhereUniqueWithoutPattern_idInput
  >;
  upsert?: Maybe<
    | StrategyPatternUpsertWithWhereUniqueWithoutPattern_idInput[]
    | StrategyPatternUpsertWithWhereUniqueWithoutPattern_idInput
  >;
  deleteMany?: Maybe<
    StrategyPatternScalarWhereInput[] | StrategyPatternScalarWhereInput
  >;
  updateMany?: Maybe<
    | StrategyPatternUpdateManyWithWhereNestedInput[]
    | StrategyPatternUpdateManyWithWhereNestedInput
  >;
}

export interface StrategyPatternUpdateWithWhereUniqueWithoutPattern_idInput {
  where: StrategyPatternWhereUniqueInput;
  data: StrategyPatternUpdateWithoutPattern_idDataInput;
}

export interface StrategyPatternUpdateWithoutPattern_idDataInput {
  strategy_id?: Maybe<
    StrategyUpdateOneRequiredWithoutStrategy_pattern_idsInput
  >;
  weight?: Maybe<Int>;
}

export interface StrategyUpdateOneRequiredWithoutStrategy_pattern_idsInput {
  create?: Maybe<StrategyCreateWithoutStrategy_pattern_idsInput>;
  update?: Maybe<StrategyUpdateWithoutStrategy_pattern_idsDataInput>;
  upsert?: Maybe<StrategyUpsertWithoutStrategy_pattern_idsInput>;
  connect?: Maybe<StrategyWhereUniqueInput>;
}

export interface StrategyUpdateWithoutStrategy_pattern_idsDataInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutStrategy_idInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CanvasUpdateManyWithoutStrategy_idInput {
  create?: Maybe<
    CanvasCreateWithoutStrategy_idInput[] | CanvasCreateWithoutStrategy_idInput
  >;
  delete?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  connect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  set?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  disconnect?: Maybe<CanvasWhereUniqueInput[] | CanvasWhereUniqueInput>;
  update?: Maybe<
    | CanvasUpdateWithWhereUniqueWithoutStrategy_idInput[]
    | CanvasUpdateWithWhereUniqueWithoutStrategy_idInput
  >;
  upsert?: Maybe<
    | CanvasUpsertWithWhereUniqueWithoutStrategy_idInput[]
    | CanvasUpsertWithWhereUniqueWithoutStrategy_idInput
  >;
  deleteMany?: Maybe<CanvasScalarWhereInput[] | CanvasScalarWhereInput>;
  updateMany?: Maybe<
    | CanvasUpdateManyWithWhereNestedInput[]
    | CanvasUpdateManyWithWhereNestedInput
  >;
}

export interface CanvasUpdateWithWhereUniqueWithoutStrategy_idInput {
  where: CanvasWhereUniqueInput;
  data: CanvasUpdateWithoutStrategy_idDataInput;
}

export interface CanvasUpdateWithoutStrategy_idDataInput {
  project_id?: Maybe<ProjectUpdateOneRequiredWithoutCanvas_idsInput>;
  pattern_ids?: Maybe<PatternUpdateManyWithoutCanvas_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CanvasUpsertWithWhereUniqueWithoutStrategy_idInput {
  where: CanvasWhereUniqueInput;
  update: CanvasUpdateWithoutStrategy_idDataInput;
  create: CanvasCreateWithoutStrategy_idInput;
}

export interface StrategyUpsertWithoutStrategy_pattern_idsInput {
  update: StrategyUpdateWithoutStrategy_pattern_idsDataInput;
  create: StrategyCreateWithoutStrategy_pattern_idsInput;
}

export interface StrategyPatternUpsertWithWhereUniqueWithoutPattern_idInput {
  where: StrategyPatternWhereUniqueInput;
  update: StrategyPatternUpdateWithoutPattern_idDataInput;
  create: StrategyPatternCreateWithoutPattern_idInput;
}

export interface PatternUpsertWithWhereUniqueWithoutCanvas_idsInput {
  where: PatternWhereUniqueInput;
  update: PatternUpdateWithoutCanvas_idsDataInput;
  create: PatternCreateWithoutCanvas_idsInput;
}

export interface PatternScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  actorWeight_not?: Maybe<Int>;
  actorWeight_in?: Maybe<Int[] | Int>;
  actorWeight_not_in?: Maybe<Int[] | Int>;
  actorWeight_lt?: Maybe<Int>;
  actorWeight_lte?: Maybe<Int>;
  actorWeight_gt?: Maybe<Int>;
  actorWeight_gte?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valuePropositionWeight_not?: Maybe<Int>;
  valuePropositionWeight_in?: Maybe<Int[] | Int>;
  valuePropositionWeight_not_in?: Maybe<Int[] | Int>;
  valuePropositionWeight_lt?: Maybe<Int>;
  valuePropositionWeight_lte?: Maybe<Int>;
  valuePropositionWeight_gt?: Maybe<Int>;
  valuePropositionWeight_gte?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueCreationWeight_not?: Maybe<Int>;
  valueCreationWeight_in?: Maybe<Int[] | Int>;
  valueCreationWeight_not_in?: Maybe<Int[] | Int>;
  valueCreationWeight_lt?: Maybe<Int>;
  valueCreationWeight_lte?: Maybe<Int>;
  valueCreationWeight_gt?: Maybe<Int>;
  valueCreationWeight_gte?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  valueDeliveryWeight_not?: Maybe<Int>;
  valueDeliveryWeight_in?: Maybe<Int[] | Int>;
  valueDeliveryWeight_not_in?: Maybe<Int[] | Int>;
  valueDeliveryWeight_lt?: Maybe<Int>;
  valueDeliveryWeight_lte?: Maybe<Int>;
  valueDeliveryWeight_gt?: Maybe<Int>;
  valueDeliveryWeight_gte?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  revenueWeight_not?: Maybe<Int>;
  revenueWeight_in?: Maybe<Int[] | Int>;
  revenueWeight_not_in?: Maybe<Int[] | Int>;
  revenueWeight_lt?: Maybe<Int>;
  revenueWeight_lte?: Maybe<Int>;
  revenueWeight_gt?: Maybe<Int>;
  revenueWeight_gte?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  expenseWeight_not?: Maybe<Int>;
  expenseWeight_in?: Maybe<Int[] | Int>;
  expenseWeight_not_in?: Maybe<Int[] | Int>;
  expenseWeight_lt?: Maybe<Int>;
  expenseWeight_lte?: Maybe<Int>;
  expenseWeight_gt?: Maybe<Int>;
  expenseWeight_gte?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  networkEffectWeight_not?: Maybe<Int>;
  networkEffectWeight_in?: Maybe<Int[] | Int>;
  networkEffectWeight_not_in?: Maybe<Int[] | Int>;
  networkEffectWeight_lt?: Maybe<Int>;
  networkEffectWeight_lte?: Maybe<Int>;
  networkEffectWeight_gt?: Maybe<Int>;
  networkEffectWeight_gte?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  regulatoryWeight_not?: Maybe<Int>;
  regulatoryWeight_in?: Maybe<Int[] | Int>;
  regulatoryWeight_not_in?: Maybe<Int[] | Int>;
  regulatoryWeight_lt?: Maybe<Int>;
  regulatoryWeight_lte?: Maybe<Int>;
  regulatoryWeight_gt?: Maybe<Int>;
  regulatoryWeight_gte?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  technicalInfrastructureWeight_not?: Maybe<Int>;
  technicalInfrastructureWeight_in?: Maybe<Int[] | Int>;
  technicalInfrastructureWeight_not_in?: Maybe<Int[] | Int>;
  technicalInfrastructureWeight_lt?: Maybe<Int>;
  technicalInfrastructureWeight_lte?: Maybe<Int>;
  technicalInfrastructureWeight_gt?: Maybe<Int>;
  technicalInfrastructureWeight_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
  OR?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
  NOT?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
}

export interface PatternUpdateManyWithWhereNestedInput {
  where: PatternScalarWhereInput;
  data: PatternUpdateManyDataInput;
}

export interface PatternUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
}

export interface CanvasUpsertWithWhereUniqueWithoutProject_idInput {
  where: CanvasWhereUniqueInput;
  update: CanvasUpdateWithoutProject_idDataInput;
  create: CanvasCreateWithoutProject_idInput;
}

export interface ProjectUpsertWithWhereUniqueWithoutUser_idInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutUser_idDataInput;
  create: ProjectCreateWithoutUser_idInput;
}

export interface ProjectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  OR?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  NOT?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface ProjectUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ValuePropositionUpsertWithWhereUniqueWithoutTable_idsInput {
  where: ValuePropositionWhereUniqueInput;
  update: ValuePropositionUpdateWithoutTable_idsDataInput;
  create: ValuePropositionCreateWithoutTable_idsInput;
}

export interface ValuePropositionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ValuePropositionScalarWhereInput[] | ValuePropositionScalarWhereInput
  >;
  OR?: Maybe<
    ValuePropositionScalarWhereInput[] | ValuePropositionScalarWhereInput
  >;
  NOT?: Maybe<
    ValuePropositionScalarWhereInput[] | ValuePropositionScalarWhereInput
  >;
}

export interface ValuePropositionUpdateManyWithWhereNestedInput {
  where: ValuePropositionScalarWhereInput;
  data: ValuePropositionUpdateManyDataInput;
}

export interface ValuePropositionUpdateManyDataInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface TableUpsertWithWhereUniqueWithoutActor_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutActor_entry_idsDataInput;
  create: TableCreateWithoutActor_entry_idsInput;
}

export interface TableScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
  OR?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
  NOT?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface ActorUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface CanvasCreateInput {
  id?: Maybe<ID_Input>;
  project_id: ProjectCreateOneWithoutCanvas_idsInput;
  strategy_id?: Maybe<StrategyCreateOneWithoutCanvas_idsInput>;
  pattern_ids?: Maybe<PatternCreateManyWithoutCanvas_idsInput>;
  table_id: TableCreateOneInput;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CanvasUpdateInput {
  project_id?: Maybe<ProjectUpdateOneRequiredWithoutCanvas_idsInput>;
  strategy_id?: Maybe<StrategyUpdateOneWithoutCanvas_idsInput>;
  pattern_ids?: Maybe<PatternUpdateManyWithoutCanvas_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface CanvasUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  pattern_ids?: Maybe<PatternCreateManyWithoutCompany_idsInput>;
  name: String;
  description?: Maybe<String>;
}

export interface PatternCreateManyWithoutCompany_idsInput {
  create?: Maybe<
    | PatternCreateWithoutCompany_idsInput[]
    | PatternCreateWithoutCompany_idsInput
  >;
  connect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
}

export interface PatternCreateWithoutCompany_idsInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutPattern_idsInput>;
  table_id: TableCreateOneInput;
  strategy_pattern_ids?: Maybe<StrategyPatternCreateManyWithoutPattern_idInput>;
  name: String;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface CompanyUpdateInput {
  pattern_ids?: Maybe<PatternUpdateManyWithoutCompany_idsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface PatternUpdateManyWithoutCompany_idsInput {
  create?: Maybe<
    | PatternCreateWithoutCompany_idsInput[]
    | PatternCreateWithoutCompany_idsInput
  >;
  delete?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  connect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  set?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  disconnect?: Maybe<PatternWhereUniqueInput[] | PatternWhereUniqueInput>;
  update?: Maybe<
    | PatternUpdateWithWhereUniqueWithoutCompany_idsInput[]
    | PatternUpdateWithWhereUniqueWithoutCompany_idsInput
  >;
  upsert?: Maybe<
    | PatternUpsertWithWhereUniqueWithoutCompany_idsInput[]
    | PatternUpsertWithWhereUniqueWithoutCompany_idsInput
  >;
  deleteMany?: Maybe<PatternScalarWhereInput[] | PatternScalarWhereInput>;
  updateMany?: Maybe<
    | PatternUpdateManyWithWhereNestedInput[]
    | PatternUpdateManyWithWhereNestedInput
  >;
}

export interface PatternUpdateWithWhereUniqueWithoutCompany_idsInput {
  where: PatternWhereUniqueInput;
  data: PatternUpdateWithoutCompany_idsDataInput;
}

export interface PatternUpdateWithoutCompany_idsDataInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutPattern_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  strategy_pattern_ids?: Maybe<StrategyPatternUpdateManyWithoutPattern_idInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface PatternUpsertWithWhereUniqueWithoutCompany_idsInput {
  where: PatternWhereUniqueInput;
  update: PatternUpdateWithoutCompany_idsDataInput;
  create: PatternCreateWithoutCompany_idsInput;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ExpenseCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutExpense_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutExpense_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutExpense_entry_idsInput[]
    | TableCreateWithoutExpense_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutExpense_entry_idsInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface ExpenseUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutExpense_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutExpense_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutExpense_entry_idsInput[]
    | TableCreateWithoutExpense_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutExpense_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutExpense_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutExpense_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutExpense_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutExpense_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutExpense_entry_idsDataInput;
}

export interface TableUpdateWithoutExpense_entry_idsDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutExpense_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutExpense_entry_idsDataInput;
  create: TableCreateWithoutExpense_entry_idsInput;
}

export interface ExpenseUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface NetworkEffectCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutNetwork_effect_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutNetwork_effect_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutNetwork_effect_entry_idsInput[]
    | TableCreateWithoutNetwork_effect_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutNetwork_effect_entry_idsInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface NetworkEffectUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutNetwork_effect_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutNetwork_effect_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutNetwork_effect_entry_idsInput[]
    | TableCreateWithoutNetwork_effect_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutNetwork_effect_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutNetwork_effect_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutNetwork_effect_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutNetwork_effect_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutNetwork_effect_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutNetwork_effect_entry_idsDataInput;
}

export interface TableUpdateWithoutNetwork_effect_entry_idsDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutNetwork_effect_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutNetwork_effect_entry_idsDataInput;
  create: TableCreateWithoutNetwork_effect_entry_idsInput;
}

export interface NetworkEffectUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface PatternCreateInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutPattern_idsInput>;
  table_id: TableCreateOneInput;
  company_ids?: Maybe<CompanyCreateManyWithoutPattern_idsInput>;
  strategy_pattern_ids?: Maybe<StrategyPatternCreateManyWithoutPattern_idInput>;
  name: String;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface PatternUpdateInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutPattern_idsInput>;
  table_id?: Maybe<TableUpdateOneRequiredInput>;
  company_ids?: Maybe<CompanyUpdateManyWithoutPattern_idsInput>;
  strategy_pattern_ids?: Maybe<StrategyPatternUpdateManyWithoutPattern_idInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface PatternUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  actorWeight?: Maybe<Int>;
  valuePropositionWeight?: Maybe<Int>;
  valueCreationWeight?: Maybe<Int>;
  valueDeliveryWeight?: Maybe<Int>;
  revenueWeight?: Maybe<Int>;
  expenseWeight?: Maybe<Int>;
  networkEffectWeight?: Maybe<Int>;
  regulatoryWeight?: Maybe<Int>;
  technicalInfrastructureWeight?: Maybe<Int>;
}

export interface ProjectCreateInput {
  id?: Maybe<ID_Input>;
  user_id: UserCreateOneWithoutProject_idsInput;
  canvas_ids?: Maybe<CanvasCreateManyWithoutProject_idInput>;
  name: String;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface ProjectUpdateInput {
  user_id?: Maybe<UserUpdateOneRequiredWithoutProject_idsInput>;
  canvas_ids?: Maybe<CanvasUpdateManyWithoutProject_idInput>;
  name?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ProjectUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface RegulatoryCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutRegulatory_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutRegulatory_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutRegulatory_entry_idsInput[]
    | TableCreateWithoutRegulatory_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutRegulatory_entry_idsInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
}

export interface RegulatoryUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutRegulatory_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutRegulatory_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutRegulatory_entry_idsInput[]
    | TableCreateWithoutRegulatory_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutRegulatory_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutRegulatory_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutRegulatory_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutRegulatory_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutRegulatory_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutRegulatory_entry_idsDataInput;
}

export interface TableUpdateWithoutRegulatory_entry_idsDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
}

export interface TableUpsertWithWhereUniqueWithoutRegulatory_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutRegulatory_entry_idsDataInput;
  create: TableCreateWithoutRegulatory_entry_idsInput;
}

export interface RegulatoryUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface RevenueCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutRevenue_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutRevenue_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutRevenue_entry_idsInput[]
    | TableCreateWithoutRevenue_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutRevenue_entry_idsInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface RevenueUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutRevenue_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutRevenue_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutRevenue_entry_idsInput[]
    | TableCreateWithoutRevenue_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutRevenue_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutRevenue_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutRevenue_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutRevenue_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutRevenue_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutRevenue_entry_idsDataInput;
}

export interface TableUpdateWithoutRevenue_entry_idsDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutRevenue_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutRevenue_entry_idsDataInput;
  create: TableCreateWithoutRevenue_entry_idsInput;
}

export interface RevenueUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface StrategyCreateInput {
  id?: Maybe<ID_Input>;
  canvas_ids?: Maybe<CanvasCreateManyWithoutStrategy_idInput>;
  strategy_pattern_ids?: Maybe<
    StrategyPatternCreateManyWithoutStrategy_idInput
  >;
  name: String;
  description?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface StrategyUpdateInput {
  canvas_ids?: Maybe<CanvasUpdateManyWithoutStrategy_idInput>;
  strategy_pattern_ids?: Maybe<
    StrategyPatternUpdateManyWithoutStrategy_idInput
  >;
  name?: Maybe<String>;
  description?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface StrategyUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface StrategyPatternCreateInput {
  id?: Maybe<ID_Input>;
  strategy_id: StrategyCreateOneWithoutStrategy_pattern_idsInput;
  pattern_id: PatternCreateOneWithoutStrategy_pattern_idsInput;
  weight: Int;
}

export interface StrategyPatternUpdateInput {
  strategy_id?: Maybe<
    StrategyUpdateOneRequiredWithoutStrategy_pattern_idsInput
  >;
  pattern_id?: Maybe<PatternUpdateOneRequiredWithoutStrategy_pattern_idsInput>;
  weight?: Maybe<Int>;
}

export interface StrategyPatternUpdateManyMutationInput {
  weight?: Maybe<Int>;
}

export interface TableUpdateInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface TechnicalInfrastructureCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<
    TableCreateManyWithoutTechnical_infrastructure_entry_idsInput
  >;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutTechnical_infrastructure_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutTechnical_infrastructure_entry_idsInput[]
    | TableCreateWithoutTechnical_infrastructure_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutTechnical_infrastructure_entry_idsInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface TechnicalInfrastructureUpdateInput {
  table_ids?: Maybe<
    TableUpdateManyWithoutTechnical_infrastructure_entry_idsInput
  >;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutTechnical_infrastructure_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutTechnical_infrastructure_entry_idsInput[]
    | TableCreateWithoutTechnical_infrastructure_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutTechnical_infrastructure_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutTechnical_infrastructure_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutTechnical_infrastructure_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutTechnical_infrastructure_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutTechnical_infrastructure_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutTechnical_infrastructure_entry_idsDataInput;
}

export interface TableUpdateWithoutTechnical_infrastructure_entry_idsDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutTechnical_infrastructure_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutTechnical_infrastructure_entry_idsDataInput;
  create: TableCreateWithoutTechnical_infrastructure_entry_idsInput;
}

export interface TechnicalInfrastructureUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface UserUpdateInput {
  project_ids?: Maybe<ProjectUpdateManyWithoutUser_idInput>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
  updatedBy?: Maybe<UserUpdateOneWithoutUpdatedByInput>;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  verificationCode?: Maybe<String>;
  verified?: Maybe<Boolean>;
  phoneNumber?: Maybe<String>;
}

export interface ValueCreationCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutValue_creation_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutValue_creation_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutValue_creation_entry_idsInput[]
    | TableCreateWithoutValue_creation_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutValue_creation_entry_idsInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface ValueCreationUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutValue_creation_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutValue_creation_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutValue_creation_entry_idsInput[]
    | TableCreateWithoutValue_creation_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutValue_creation_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutValue_creation_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutValue_creation_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutValue_creation_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutValue_creation_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutValue_creation_entry_idsDataInput;
}

export interface TableUpdateWithoutValue_creation_entry_idsDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutValue_creation_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutValue_creation_entry_idsDataInput;
  create: TableCreateWithoutValue_creation_entry_idsInput;
}

export interface ValueCreationUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface ValueDeliveryCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutValue_delivery_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutValue_delivery_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutValue_delivery_entry_idsInput[]
    | TableCreateWithoutValue_delivery_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutValue_delivery_entry_idsInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionCreateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface ValueDeliveryUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutValue_delivery_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutValue_delivery_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutValue_delivery_entry_idsInput[]
    | TableCreateWithoutValue_delivery_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutValue_delivery_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutValue_delivery_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutValue_delivery_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutValue_delivery_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutValue_delivery_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutValue_delivery_entry_idsDataInput;
}

export interface TableUpdateWithoutValue_delivery_entry_idsDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_proposition_entry_ids?: Maybe<
    ValuePropositionUpdateManyWithoutTable_idsInput
  >;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutValue_delivery_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutValue_delivery_entry_idsDataInput;
  create: TableCreateWithoutValue_delivery_entry_idsInput;
}

export interface ValueDeliveryUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface ValuePropositionCreateInput {
  id?: Maybe<ID_Input>;
  table_ids?: Maybe<TableCreateManyWithoutValue_proposition_entry_idsInput>;
  text: String;
  note?: Maybe<String>;
  createdBy: UserCreateOneInput;
  updatedBy: UserCreateOneInput;
}

export interface TableCreateManyWithoutValue_proposition_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutValue_proposition_entry_idsInput[]
    | TableCreateWithoutValue_proposition_entry_idsInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutValue_proposition_entry_idsInput {
  id?: Maybe<ID_Input>;
  actor_entry_ids?: Maybe<ActorCreateManyWithoutTable_idsInput>;
  value_creation_entry_ids?: Maybe<
    ValueCreationCreateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryCreateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueCreateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseCreateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectCreateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureCreateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryCreateManyWithoutTable_idsInput>;
}

export interface ValuePropositionUpdateInput {
  table_ids?: Maybe<TableUpdateManyWithoutValue_proposition_entry_idsInput>;
  text?: Maybe<String>;
  note?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TableUpdateManyWithoutValue_proposition_entry_idsInput {
  create?: Maybe<
    | TableCreateWithoutValue_proposition_entry_idsInput[]
    | TableCreateWithoutValue_proposition_entry_idsInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutValue_proposition_entry_idsInput[]
    | TableUpdateWithWhereUniqueWithoutValue_proposition_entry_idsInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutValue_proposition_entry_idsInput[]
    | TableUpsertWithWhereUniqueWithoutValue_proposition_entry_idsInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateWithWhereUniqueWithoutValue_proposition_entry_idsInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutValue_proposition_entry_idsDataInput;
}

export interface TableUpdateWithoutValue_proposition_entry_idsDataInput {
  actor_entry_ids?: Maybe<ActorUpdateManyWithoutTable_idsInput>;
  value_creation_entry_ids?: Maybe<
    ValueCreationUpdateManyWithoutTable_idsInput
  >;
  value_delivery_entry_ids?: Maybe<
    ValueDeliveryUpdateManyWithoutTable_idsInput
  >;
  revenue_entry_ids?: Maybe<RevenueUpdateManyWithoutTable_idsInput>;
  expense_entry_ids?: Maybe<ExpenseUpdateManyWithoutTable_idsInput>;
  network_effect_entry_ids?: Maybe<
    NetworkEffectUpdateManyWithoutTable_idsInput
  >;
  technical_infrastructure_entry_ids?: Maybe<
    TechnicalInfrastructureUpdateManyWithoutTable_idsInput
  >;
  regulatory_entry_ids?: Maybe<RegulatoryUpdateManyWithoutTable_idsInput>;
}

export interface TableUpsertWithWhereUniqueWithoutValue_proposition_entry_idsInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutValue_proposition_entry_idsDataInput;
  create: TableCreateWithoutValue_proposition_entry_idsInput;
}

export interface ValuePropositionUpdateManyMutationInput {
  text?: Maybe<String>;
  note?: Maybe<String>;
}

export interface ActorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActorWhereInput>;
  AND?: Maybe<ActorSubscriptionWhereInput[] | ActorSubscriptionWhereInput>;
  OR?: Maybe<ActorSubscriptionWhereInput[] | ActorSubscriptionWhereInput>;
  NOT?: Maybe<ActorSubscriptionWhereInput[] | ActorSubscriptionWhereInput>;
}

export interface CanvasSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CanvasWhereInput>;
  AND?: Maybe<CanvasSubscriptionWhereInput[] | CanvasSubscriptionWhereInput>;
  OR?: Maybe<CanvasSubscriptionWhereInput[] | CanvasSubscriptionWhereInput>;
  NOT?: Maybe<CanvasSubscriptionWhereInput[] | CanvasSubscriptionWhereInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface ExpenseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseWhereInput>;
  AND?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
  OR?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
  NOT?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
}

export interface NetworkEffectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NetworkEffectWhereInput>;
  AND?: Maybe<
    NetworkEffectSubscriptionWhereInput[] | NetworkEffectSubscriptionWhereInput
  >;
  OR?: Maybe<
    NetworkEffectSubscriptionWhereInput[] | NetworkEffectSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NetworkEffectSubscriptionWhereInput[] | NetworkEffectSubscriptionWhereInput
  >;
}

export interface PatternSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PatternWhereInput>;
  AND?: Maybe<PatternSubscriptionWhereInput[] | PatternSubscriptionWhereInput>;
  OR?: Maybe<PatternSubscriptionWhereInput[] | PatternSubscriptionWhereInput>;
  NOT?: Maybe<PatternSubscriptionWhereInput[] | PatternSubscriptionWhereInput>;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectWhereInput>;
  AND?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  OR?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  NOT?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
}

export interface RegulatorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RegulatoryWhereInput>;
  AND?: Maybe<
    RegulatorySubscriptionWhereInput[] | RegulatorySubscriptionWhereInput
  >;
  OR?: Maybe<
    RegulatorySubscriptionWhereInput[] | RegulatorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    RegulatorySubscriptionWhereInput[] | RegulatorySubscriptionWhereInput
  >;
}

export interface RevenueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RevenueWhereInput>;
  AND?: Maybe<RevenueSubscriptionWhereInput[] | RevenueSubscriptionWhereInput>;
  OR?: Maybe<RevenueSubscriptionWhereInput[] | RevenueSubscriptionWhereInput>;
  NOT?: Maybe<RevenueSubscriptionWhereInput[] | RevenueSubscriptionWhereInput>;
}

export interface StrategySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StrategyWhereInput>;
  AND?: Maybe<
    StrategySubscriptionWhereInput[] | StrategySubscriptionWhereInput
  >;
  OR?: Maybe<StrategySubscriptionWhereInput[] | StrategySubscriptionWhereInput>;
  NOT?: Maybe<
    StrategySubscriptionWhereInput[] | StrategySubscriptionWhereInput
  >;
}

export interface StrategyPatternSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StrategyPatternWhereInput>;
  AND?: Maybe<
    | StrategyPatternSubscriptionWhereInput[]
    | StrategyPatternSubscriptionWhereInput
  >;
  OR?: Maybe<
    | StrategyPatternSubscriptionWhereInput[]
    | StrategyPatternSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | StrategyPatternSubscriptionWhereInput[]
    | StrategyPatternSubscriptionWhereInput
  >;
}

export interface TableSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TableWhereInput>;
  AND?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
  OR?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
  NOT?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
}

export interface TechnicalInfrastructureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TechnicalInfrastructureWhereInput>;
  AND?: Maybe<
    | TechnicalInfrastructureSubscriptionWhereInput[]
    | TechnicalInfrastructureSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TechnicalInfrastructureSubscriptionWhereInput[]
    | TechnicalInfrastructureSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TechnicalInfrastructureSubscriptionWhereInput[]
    | TechnicalInfrastructureSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ValueCreationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ValueCreationWhereInput>;
  AND?: Maybe<
    ValueCreationSubscriptionWhereInput[] | ValueCreationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ValueCreationSubscriptionWhereInput[] | ValueCreationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ValueCreationSubscriptionWhereInput[] | ValueCreationSubscriptionWhereInput
  >;
}

export interface ValueDeliverySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ValueDeliveryWhereInput>;
  AND?: Maybe<
    ValueDeliverySubscriptionWhereInput[] | ValueDeliverySubscriptionWhereInput
  >;
  OR?: Maybe<
    ValueDeliverySubscriptionWhereInput[] | ValueDeliverySubscriptionWhereInput
  >;
  NOT?: Maybe<
    ValueDeliverySubscriptionWhereInput[] | ValueDeliverySubscriptionWhereInput
  >;
}

export interface ValuePropositionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ValuePropositionWhereInput>;
  AND?: Maybe<
    | ValuePropositionSubscriptionWhereInput[]
    | ValuePropositionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ValuePropositionSubscriptionWhereInput[]
    | ValuePropositionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ValuePropositionSubscriptionWhereInput[]
    | ValuePropositionSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Actor {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ActorPromise extends Promise<Actor>, Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ActorSubscription
  extends Promise<AsyncIterator<Actor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ActorNullablePromise
  extends Promise<Actor | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Table {
  id: ID_Output;
}

export interface TablePromise extends Promise<Table>, Fragmentable {
  id: () => Promise<ID_Output>;
  actor_entry_ids: <T = FragmentableArray<Actor>>(args?: {
    where?: ActorWhereInput;
    orderBy?: ActorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_proposition_entry_ids: <
    T = FragmentableArray<ValueProposition>
  >(args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_creation_entry_ids: <T = FragmentableArray<ValueCreation>>(args?: {
    where?: ValueCreationWhereInput;
    orderBy?: ValueCreationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_delivery_entry_ids: <T = FragmentableArray<ValueDelivery>>(args?: {
    where?: ValueDeliveryWhereInput;
    orderBy?: ValueDeliveryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  revenue_entry_ids: <T = FragmentableArray<Revenue>>(args?: {
    where?: RevenueWhereInput;
    orderBy?: RevenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expense_entry_ids: <T = FragmentableArray<Expense>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  network_effect_entry_ids: <T = FragmentableArray<NetworkEffect>>(args?: {
    where?: NetworkEffectWhereInput;
    orderBy?: NetworkEffectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  technical_infrastructure_entry_ids: <
    T = FragmentableArray<TechnicalInfrastructure>
  >(args?: {
    where?: TechnicalInfrastructureWhereInput;
    orderBy?: TechnicalInfrastructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regulatory_entry_ids: <T = FragmentableArray<Regulatory>>(args?: {
    where?: RegulatoryWhereInput;
    orderBy?: RegulatoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TableSubscription
  extends Promise<AsyncIterator<Table>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  actor_entry_ids: <T = Promise<AsyncIterator<ActorSubscription>>>(args?: {
    where?: ActorWhereInput;
    orderBy?: ActorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_proposition_entry_ids: <
    T = Promise<AsyncIterator<ValuePropositionSubscription>>
  >(args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_creation_entry_ids: <
    T = Promise<AsyncIterator<ValueCreationSubscription>>
  >(args?: {
    where?: ValueCreationWhereInput;
    orderBy?: ValueCreationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_delivery_entry_ids: <
    T = Promise<AsyncIterator<ValueDeliverySubscription>>
  >(args?: {
    where?: ValueDeliveryWhereInput;
    orderBy?: ValueDeliveryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  revenue_entry_ids: <T = Promise<AsyncIterator<RevenueSubscription>>>(args?: {
    where?: RevenueWhereInput;
    orderBy?: RevenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expense_entry_ids: <T = Promise<AsyncIterator<ExpenseSubscription>>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  network_effect_entry_ids: <
    T = Promise<AsyncIterator<NetworkEffectSubscription>>
  >(args?: {
    where?: NetworkEffectWhereInput;
    orderBy?: NetworkEffectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  technical_infrastructure_entry_ids: <
    T = Promise<AsyncIterator<TechnicalInfrastructureSubscription>>
  >(args?: {
    where?: TechnicalInfrastructureWhereInput;
    orderBy?: TechnicalInfrastructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regulatory_entry_ids: <
    T = Promise<AsyncIterator<RegulatorySubscription>>
  >(args?: {
    where?: RegulatoryWhereInput;
    orderBy?: RegulatoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TableNullablePromise
  extends Promise<Table | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  actor_entry_ids: <T = FragmentableArray<Actor>>(args?: {
    where?: ActorWhereInput;
    orderBy?: ActorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_proposition_entry_ids: <
    T = FragmentableArray<ValueProposition>
  >(args?: {
    where?: ValuePropositionWhereInput;
    orderBy?: ValuePropositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_creation_entry_ids: <T = FragmentableArray<ValueCreation>>(args?: {
    where?: ValueCreationWhereInput;
    orderBy?: ValueCreationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  value_delivery_entry_ids: <T = FragmentableArray<ValueDelivery>>(args?: {
    where?: ValueDeliveryWhereInput;
    orderBy?: ValueDeliveryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  revenue_entry_ids: <T = FragmentableArray<Revenue>>(args?: {
    where?: RevenueWhereInput;
    orderBy?: RevenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expense_entry_ids: <T = FragmentableArray<Expense>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  network_effect_entry_ids: <T = FragmentableArray<NetworkEffect>>(args?: {
    where?: NetworkEffectWhereInput;
    orderBy?: NetworkEffectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  technical_infrastructure_entry_ids: <
    T = FragmentableArray<TechnicalInfrastructure>
  >(args?: {
    where?: TechnicalInfrastructureWhereInput;
    orderBy?: TechnicalInfrastructureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regulatory_entry_ids: <T = FragmentableArray<Regulatory>>(args?: {
    where?: RegulatoryWhereInput;
    orderBy?: RegulatoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ValueProposition {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ValuePropositionPromise
  extends Promise<ValueProposition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValuePropositionSubscription
  extends Promise<AsyncIterator<ValueProposition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ValuePropositionNullablePromise
  extends Promise<ValueProposition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  role: Role;
  password: String;
  verificationCode?: String;
  verified: Boolean;
  phoneNumber?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  project_ids: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  phoneNumber: () => Promise<String>;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  project_ids: <T = Promise<AsyncIterator<ProjectSubscription>>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  password: () => Promise<AsyncIterator<String>>;
  verificationCode: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  project_ids: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  phoneNumber: () => Promise<String>;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Project {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  user_id: <T = UserPromise>() => T;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user_id: <T = UserSubscription>() => T;
  canvas_ids: <T = Promise<AsyncIterator<CanvasSubscription>>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectNullablePromise
  extends Promise<Project | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user_id: <T = UserPromise>() => T;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Canvas {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CanvasPromise extends Promise<Canvas>, Fragmentable {
  id: () => Promise<ID_Output>;
  project_id: <T = ProjectPromise>() => T;
  strategy_id: <T = StrategyPromise>() => T;
  pattern_ids: <T = FragmentableArray<Pattern>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TablePromise>() => T;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CanvasSubscription
  extends Promise<AsyncIterator<Canvas>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  project_id: <T = ProjectSubscription>() => T;
  strategy_id: <T = StrategySubscription>() => T;
  pattern_ids: <T = Promise<AsyncIterator<PatternSubscription>>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TableSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CanvasNullablePromise
  extends Promise<Canvas | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  project_id: <T = ProjectPromise>() => T;
  strategy_id: <T = StrategyPromise>() => T;
  pattern_ids: <T = FragmentableArray<Pattern>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TablePromise>() => T;
  name: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Strategy {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StrategyPromise extends Promise<Strategy>, Fragmentable {
  id: () => Promise<ID_Output>;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  strategy_pattern_ids: <T = FragmentableArray<StrategyPattern>>(args?: {
    where?: StrategyPatternWhereInput;
    orderBy?: StrategyPatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StrategySubscription
  extends Promise<AsyncIterator<Strategy>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  canvas_ids: <T = Promise<AsyncIterator<CanvasSubscription>>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  strategy_pattern_ids: <
    T = Promise<AsyncIterator<StrategyPatternSubscription>>
  >(args?: {
    where?: StrategyPatternWhereInput;
    orderBy?: StrategyPatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StrategyNullablePromise
  extends Promise<Strategy | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  strategy_pattern_ids: <T = FragmentableArray<StrategyPattern>>(args?: {
    where?: StrategyPatternWhereInput;
    orderBy?: StrategyPatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StrategyPattern {
  id: ID_Output;
  weight: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StrategyPatternPromise
  extends Promise<StrategyPattern>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  strategy_id: <T = StrategyPromise>() => T;
  pattern_id: <T = PatternPromise>() => T;
  weight: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StrategyPatternSubscription
  extends Promise<AsyncIterator<StrategyPattern>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  strategy_id: <T = StrategySubscription>() => T;
  pattern_id: <T = PatternSubscription>() => T;
  weight: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StrategyPatternNullablePromise
  extends Promise<StrategyPattern | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  strategy_id: <T = StrategyPromise>() => T;
  pattern_id: <T = PatternPromise>() => T;
  weight: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Pattern {
  id: ID_Output;
  name: String;
  description?: String;
  actorWeight?: Int;
  valuePropositionWeight?: Int;
  valueCreationWeight?: Int;
  valueDeliveryWeight?: Int;
  revenueWeight?: Int;
  expenseWeight?: Int;
  networkEffectWeight?: Int;
  regulatoryWeight?: Int;
  technicalInfrastructureWeight?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PatternPromise extends Promise<Pattern>, Fragmentable {
  id: () => Promise<ID_Output>;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TablePromise>() => T;
  company_ids: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  strategy_pattern_ids: <T = FragmentableArray<StrategyPattern>>(args?: {
    where?: StrategyPatternWhereInput;
    orderBy?: StrategyPatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  actorWeight: () => Promise<Int>;
  valuePropositionWeight: () => Promise<Int>;
  valueCreationWeight: () => Promise<Int>;
  valueDeliveryWeight: () => Promise<Int>;
  revenueWeight: () => Promise<Int>;
  expenseWeight: () => Promise<Int>;
  networkEffectWeight: () => Promise<Int>;
  regulatoryWeight: () => Promise<Int>;
  technicalInfrastructureWeight: () => Promise<Int>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatternSubscription
  extends Promise<AsyncIterator<Pattern>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  canvas_ids: <T = Promise<AsyncIterator<CanvasSubscription>>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TableSubscription>() => T;
  company_ids: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  strategy_pattern_ids: <
    T = Promise<AsyncIterator<StrategyPatternSubscription>>
  >(args?: {
    where?: StrategyPatternWhereInput;
    orderBy?: StrategyPatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  actorWeight: () => Promise<AsyncIterator<Int>>;
  valuePropositionWeight: () => Promise<AsyncIterator<Int>>;
  valueCreationWeight: () => Promise<AsyncIterator<Int>>;
  valueDeliveryWeight: () => Promise<AsyncIterator<Int>>;
  revenueWeight: () => Promise<AsyncIterator<Int>>;
  expenseWeight: () => Promise<AsyncIterator<Int>>;
  networkEffectWeight: () => Promise<AsyncIterator<Int>>;
  regulatoryWeight: () => Promise<AsyncIterator<Int>>;
  technicalInfrastructureWeight: () => Promise<AsyncIterator<Int>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PatternNullablePromise
  extends Promise<Pattern | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  canvas_ids: <T = FragmentableArray<Canvas>>(args?: {
    where?: CanvasWhereInput;
    orderBy?: CanvasOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  table_id: <T = TablePromise>() => T;
  company_ids: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  strategy_pattern_ids: <T = FragmentableArray<StrategyPattern>>(args?: {
    where?: StrategyPatternWhereInput;
    orderBy?: StrategyPatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  actorWeight: () => Promise<Int>;
  valuePropositionWeight: () => Promise<Int>;
  valueCreationWeight: () => Promise<Int>;
  valueDeliveryWeight: () => Promise<Int>;
  revenueWeight: () => Promise<Int>;
  expenseWeight: () => Promise<Int>;
  networkEffectWeight: () => Promise<Int>;
  regulatoryWeight: () => Promise<Int>;
  technicalInfrastructureWeight: () => Promise<Int>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Company {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  pattern_ids: <T = FragmentableArray<Pattern>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pattern_ids: <T = Promise<AsyncIterator<PatternSubscription>>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pattern_ids: <T = FragmentableArray<Pattern>>(args?: {
    where?: PatternWhereInput;
    orderBy?: PatternOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValueCreation {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ValueCreationPromise
  extends Promise<ValueCreation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValueCreationSubscription
  extends Promise<AsyncIterator<ValueCreation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ValueCreationNullablePromise
  extends Promise<ValueCreation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValueDelivery {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ValueDeliveryPromise
  extends Promise<ValueDelivery>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValueDeliverySubscription
  extends Promise<AsyncIterator<ValueDelivery>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ValueDeliveryNullablePromise
  extends Promise<ValueDelivery | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Revenue {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RevenuePromise extends Promise<Revenue>, Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RevenueSubscription
  extends Promise<AsyncIterator<Revenue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RevenueNullablePromise
  extends Promise<Revenue | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Expense {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExpensePromise extends Promise<Expense>, Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExpenseSubscription
  extends Promise<AsyncIterator<Expense>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseNullablePromise
  extends Promise<Expense | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NetworkEffect {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NetworkEffectPromise
  extends Promise<NetworkEffect>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NetworkEffectSubscription
  extends Promise<AsyncIterator<NetworkEffect>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NetworkEffectNullablePromise
  extends Promise<NetworkEffect | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TechnicalInfrastructure {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TechnicalInfrastructurePromise
  extends Promise<TechnicalInfrastructure>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TechnicalInfrastructureSubscription
  extends Promise<AsyncIterator<TechnicalInfrastructure>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TechnicalInfrastructureNullablePromise
  extends Promise<TechnicalInfrastructure | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Regulatory {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegulatoryPromise extends Promise<Regulatory>, Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RegulatorySubscription
  extends Promise<AsyncIterator<Regulatory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table_ids: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  updatedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegulatoryNullablePromise
  extends Promise<Regulatory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table_ids: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  updatedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ActorConnection {
  pageInfo: PageInfo;
  edges: ActorEdge[];
}

export interface ActorConnectionPromise
  extends Promise<ActorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActorEdge>>() => T;
  aggregate: <T = AggregateActorPromise>() => T;
}

export interface ActorConnectionSubscription
  extends Promise<AsyncIterator<ActorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActorSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ActorEdge {
  node: Actor;
  cursor: String;
}

export interface ActorEdgePromise extends Promise<ActorEdge>, Fragmentable {
  node: <T = ActorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActorEdgeSubscription
  extends Promise<AsyncIterator<ActorEdge>>,
    Fragmentable {
  node: <T = ActorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActor {
  count: Int;
}

export interface AggregateActorPromise
  extends Promise<AggregateActor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActorSubscription
  extends Promise<AsyncIterator<AggregateActor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CanvasConnection {
  pageInfo: PageInfo;
  edges: CanvasEdge[];
}

export interface CanvasConnectionPromise
  extends Promise<CanvasConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CanvasEdge>>() => T;
  aggregate: <T = AggregateCanvasPromise>() => T;
}

export interface CanvasConnectionSubscription
  extends Promise<AsyncIterator<CanvasConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CanvasEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCanvasSubscription>() => T;
}

export interface CanvasEdge {
  node: Canvas;
  cursor: String;
}

export interface CanvasEdgePromise extends Promise<CanvasEdge>, Fragmentable {
  node: <T = CanvasPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CanvasEdgeSubscription
  extends Promise<AsyncIterator<CanvasEdge>>,
    Fragmentable {
  node: <T = CanvasSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCanvas {
  count: Int;
}

export interface AggregateCanvasPromise
  extends Promise<AggregateCanvas>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCanvasSubscription
  extends Promise<AsyncIterator<AggregateCanvas>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseConnection {
  pageInfo: PageInfo;
  edges: ExpenseEdge[];
}

export interface ExpenseConnectionPromise
  extends Promise<ExpenseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseEdge>>() => T;
  aggregate: <T = AggregateExpensePromise>() => T;
}

export interface ExpenseConnectionSubscription
  extends Promise<AsyncIterator<ExpenseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpenseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpenseSubscription>() => T;
}

export interface ExpenseEdge {
  node: Expense;
  cursor: String;
}

export interface ExpenseEdgePromise extends Promise<ExpenseEdge>, Fragmentable {
  node: <T = ExpensePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseEdgeSubscription
  extends Promise<AsyncIterator<ExpenseEdge>>,
    Fragmentable {
  node: <T = ExpenseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpense {
  count: Int;
}

export interface AggregateExpensePromise
  extends Promise<AggregateExpense>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseSubscription
  extends Promise<AsyncIterator<AggregateExpense>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NetworkEffectConnection {
  pageInfo: PageInfo;
  edges: NetworkEffectEdge[];
}

export interface NetworkEffectConnectionPromise
  extends Promise<NetworkEffectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NetworkEffectEdge>>() => T;
  aggregate: <T = AggregateNetworkEffectPromise>() => T;
}

export interface NetworkEffectConnectionSubscription
  extends Promise<AsyncIterator<NetworkEffectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NetworkEffectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNetworkEffectSubscription>() => T;
}

export interface NetworkEffectEdge {
  node: NetworkEffect;
  cursor: String;
}

export interface NetworkEffectEdgePromise
  extends Promise<NetworkEffectEdge>,
    Fragmentable {
  node: <T = NetworkEffectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NetworkEffectEdgeSubscription
  extends Promise<AsyncIterator<NetworkEffectEdge>>,
    Fragmentable {
  node: <T = NetworkEffectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNetworkEffect {
  count: Int;
}

export interface AggregateNetworkEffectPromise
  extends Promise<AggregateNetworkEffect>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNetworkEffectSubscription
  extends Promise<AsyncIterator<AggregateNetworkEffect>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PatternConnection {
  pageInfo: PageInfo;
  edges: PatternEdge[];
}

export interface PatternConnectionPromise
  extends Promise<PatternConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PatternEdge>>() => T;
  aggregate: <T = AggregatePatternPromise>() => T;
}

export interface PatternConnectionSubscription
  extends Promise<AsyncIterator<PatternConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PatternEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePatternSubscription>() => T;
}

export interface PatternEdge {
  node: Pattern;
  cursor: String;
}

export interface PatternEdgePromise extends Promise<PatternEdge>, Fragmentable {
  node: <T = PatternPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PatternEdgeSubscription
  extends Promise<AsyncIterator<PatternEdge>>,
    Fragmentable {
  node: <T = PatternSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePattern {
  count: Int;
}

export interface AggregatePatternPromise
  extends Promise<AggregatePattern>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePatternSubscription
  extends Promise<AsyncIterator<AggregatePattern>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegulatoryConnection {
  pageInfo: PageInfo;
  edges: RegulatoryEdge[];
}

export interface RegulatoryConnectionPromise
  extends Promise<RegulatoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegulatoryEdge>>() => T;
  aggregate: <T = AggregateRegulatoryPromise>() => T;
}

export interface RegulatoryConnectionSubscription
  extends Promise<AsyncIterator<RegulatoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegulatoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegulatorySubscription>() => T;
}

export interface RegulatoryEdge {
  node: Regulatory;
  cursor: String;
}

export interface RegulatoryEdgePromise
  extends Promise<RegulatoryEdge>,
    Fragmentable {
  node: <T = RegulatoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegulatoryEdgeSubscription
  extends Promise<AsyncIterator<RegulatoryEdge>>,
    Fragmentable {
  node: <T = RegulatorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRegulatory {
  count: Int;
}

export interface AggregateRegulatoryPromise
  extends Promise<AggregateRegulatory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegulatorySubscription
  extends Promise<AsyncIterator<AggregateRegulatory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RevenueConnection {
  pageInfo: PageInfo;
  edges: RevenueEdge[];
}

export interface RevenueConnectionPromise
  extends Promise<RevenueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RevenueEdge>>() => T;
  aggregate: <T = AggregateRevenuePromise>() => T;
}

export interface RevenueConnectionSubscription
  extends Promise<AsyncIterator<RevenueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RevenueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRevenueSubscription>() => T;
}

export interface RevenueEdge {
  node: Revenue;
  cursor: String;
}

export interface RevenueEdgePromise extends Promise<RevenueEdge>, Fragmentable {
  node: <T = RevenuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RevenueEdgeSubscription
  extends Promise<AsyncIterator<RevenueEdge>>,
    Fragmentable {
  node: <T = RevenueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRevenue {
  count: Int;
}

export interface AggregateRevenuePromise
  extends Promise<AggregateRevenue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRevenueSubscription
  extends Promise<AsyncIterator<AggregateRevenue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StrategyConnection {
  pageInfo: PageInfo;
  edges: StrategyEdge[];
}

export interface StrategyConnectionPromise
  extends Promise<StrategyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StrategyEdge>>() => T;
  aggregate: <T = AggregateStrategyPromise>() => T;
}

export interface StrategyConnectionSubscription
  extends Promise<AsyncIterator<StrategyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StrategyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStrategySubscription>() => T;
}

export interface StrategyEdge {
  node: Strategy;
  cursor: String;
}

export interface StrategyEdgePromise
  extends Promise<StrategyEdge>,
    Fragmentable {
  node: <T = StrategyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StrategyEdgeSubscription
  extends Promise<AsyncIterator<StrategyEdge>>,
    Fragmentable {
  node: <T = StrategySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStrategy {
  count: Int;
}

export interface AggregateStrategyPromise
  extends Promise<AggregateStrategy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStrategySubscription
  extends Promise<AsyncIterator<AggregateStrategy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StrategyPatternConnection {
  pageInfo: PageInfo;
  edges: StrategyPatternEdge[];
}

export interface StrategyPatternConnectionPromise
  extends Promise<StrategyPatternConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StrategyPatternEdge>>() => T;
  aggregate: <T = AggregateStrategyPatternPromise>() => T;
}

export interface StrategyPatternConnectionSubscription
  extends Promise<AsyncIterator<StrategyPatternConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StrategyPatternEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStrategyPatternSubscription>() => T;
}

export interface StrategyPatternEdge {
  node: StrategyPattern;
  cursor: String;
}

export interface StrategyPatternEdgePromise
  extends Promise<StrategyPatternEdge>,
    Fragmentable {
  node: <T = StrategyPatternPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StrategyPatternEdgeSubscription
  extends Promise<AsyncIterator<StrategyPatternEdge>>,
    Fragmentable {
  node: <T = StrategyPatternSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStrategyPattern {
  count: Int;
}

export interface AggregateStrategyPatternPromise
  extends Promise<AggregateStrategyPattern>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStrategyPatternSubscription
  extends Promise<AsyncIterator<AggregateStrategyPattern>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TableConnection {
  pageInfo: PageInfo;
  edges: TableEdge[];
}

export interface TableConnectionPromise
  extends Promise<TableConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TableEdge>>() => T;
  aggregate: <T = AggregateTablePromise>() => T;
}

export interface TableConnectionSubscription
  extends Promise<AsyncIterator<TableConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TableEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTableSubscription>() => T;
}

export interface TableEdge {
  node: Table;
  cursor: String;
}

export interface TableEdgePromise extends Promise<TableEdge>, Fragmentable {
  node: <T = TablePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TableEdgeSubscription
  extends Promise<AsyncIterator<TableEdge>>,
    Fragmentable {
  node: <T = TableSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTable {
  count: Int;
}

export interface AggregateTablePromise
  extends Promise<AggregateTable>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTableSubscription
  extends Promise<AsyncIterator<AggregateTable>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TechnicalInfrastructureConnection {
  pageInfo: PageInfo;
  edges: TechnicalInfrastructureEdge[];
}

export interface TechnicalInfrastructureConnectionPromise
  extends Promise<TechnicalInfrastructureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TechnicalInfrastructureEdge>>() => T;
  aggregate: <T = AggregateTechnicalInfrastructurePromise>() => T;
}

export interface TechnicalInfrastructureConnectionSubscription
  extends Promise<AsyncIterator<TechnicalInfrastructureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TechnicalInfrastructureEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTechnicalInfrastructureSubscription>() => T;
}

export interface TechnicalInfrastructureEdge {
  node: TechnicalInfrastructure;
  cursor: String;
}

export interface TechnicalInfrastructureEdgePromise
  extends Promise<TechnicalInfrastructureEdge>,
    Fragmentable {
  node: <T = TechnicalInfrastructurePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TechnicalInfrastructureEdgeSubscription
  extends Promise<AsyncIterator<TechnicalInfrastructureEdge>>,
    Fragmentable {
  node: <T = TechnicalInfrastructureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTechnicalInfrastructure {
  count: Int;
}

export interface AggregateTechnicalInfrastructurePromise
  extends Promise<AggregateTechnicalInfrastructure>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTechnicalInfrastructureSubscription
  extends Promise<AsyncIterator<AggregateTechnicalInfrastructure>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValueCreationConnection {
  pageInfo: PageInfo;
  edges: ValueCreationEdge[];
}

export interface ValueCreationConnectionPromise
  extends Promise<ValueCreationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValueCreationEdge>>() => T;
  aggregate: <T = AggregateValueCreationPromise>() => T;
}

export interface ValueCreationConnectionSubscription
  extends Promise<AsyncIterator<ValueCreationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ValueCreationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateValueCreationSubscription>() => T;
}

export interface ValueCreationEdge {
  node: ValueCreation;
  cursor: String;
}

export interface ValueCreationEdgePromise
  extends Promise<ValueCreationEdge>,
    Fragmentable {
  node: <T = ValueCreationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ValueCreationEdgeSubscription
  extends Promise<AsyncIterator<ValueCreationEdge>>,
    Fragmentable {
  node: <T = ValueCreationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateValueCreation {
  count: Int;
}

export interface AggregateValueCreationPromise
  extends Promise<AggregateValueCreation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValueCreationSubscription
  extends Promise<AsyncIterator<AggregateValueCreation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValueDeliveryConnection {
  pageInfo: PageInfo;
  edges: ValueDeliveryEdge[];
}

export interface ValueDeliveryConnectionPromise
  extends Promise<ValueDeliveryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValueDeliveryEdge>>() => T;
  aggregate: <T = AggregateValueDeliveryPromise>() => T;
}

export interface ValueDeliveryConnectionSubscription
  extends Promise<AsyncIterator<ValueDeliveryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ValueDeliveryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateValueDeliverySubscription>() => T;
}

export interface ValueDeliveryEdge {
  node: ValueDelivery;
  cursor: String;
}

export interface ValueDeliveryEdgePromise
  extends Promise<ValueDeliveryEdge>,
    Fragmentable {
  node: <T = ValueDeliveryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ValueDeliveryEdgeSubscription
  extends Promise<AsyncIterator<ValueDeliveryEdge>>,
    Fragmentable {
  node: <T = ValueDeliverySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateValueDelivery {
  count: Int;
}

export interface AggregateValueDeliveryPromise
  extends Promise<AggregateValueDelivery>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValueDeliverySubscription
  extends Promise<AsyncIterator<AggregateValueDelivery>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValuePropositionConnection {
  pageInfo: PageInfo;
  edges: ValuePropositionEdge[];
}

export interface ValuePropositionConnectionPromise
  extends Promise<ValuePropositionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValuePropositionEdge>>() => T;
  aggregate: <T = AggregateValuePropositionPromise>() => T;
}

export interface ValuePropositionConnectionSubscription
  extends Promise<AsyncIterator<ValuePropositionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ValuePropositionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateValuePropositionSubscription>() => T;
}

export interface ValuePropositionEdge {
  node: ValueProposition;
  cursor: String;
}

export interface ValuePropositionEdgePromise
  extends Promise<ValuePropositionEdge>,
    Fragmentable {
  node: <T = ValuePropositionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ValuePropositionEdgeSubscription
  extends Promise<AsyncIterator<ValuePropositionEdge>>,
    Fragmentable {
  node: <T = ValuePropositionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateValueProposition {
  count: Int;
}

export interface AggregateValuePropositionPromise
  extends Promise<AggregateValueProposition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValuePropositionSubscription
  extends Promise<AsyncIterator<AggregateValueProposition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActorSubscriptionPayload {
  mutation: MutationType;
  node: Actor;
  updatedFields: String[];
  previousValues: ActorPreviousValues;
}

export interface ActorSubscriptionPayloadPromise
  extends Promise<ActorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActorPreviousValuesPromise>() => T;
}

export interface ActorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActorPreviousValuesSubscription>() => T;
}

export interface ActorPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ActorPreviousValuesPromise
  extends Promise<ActorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ActorPreviousValuesSubscription
  extends Promise<AsyncIterator<ActorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CanvasSubscriptionPayload {
  mutation: MutationType;
  node: Canvas;
  updatedFields: String[];
  previousValues: CanvasPreviousValues;
}

export interface CanvasSubscriptionPayloadPromise
  extends Promise<CanvasSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CanvasPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CanvasPreviousValuesPromise>() => T;
}

export interface CanvasSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CanvasSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CanvasSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CanvasPreviousValuesSubscription>() => T;
}

export interface CanvasPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CanvasPreviousValuesPromise
  extends Promise<CanvasPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CanvasPreviousValuesSubscription
  extends Promise<AsyncIterator<CanvasPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseSubscriptionPayload {
  mutation: MutationType;
  node: Expense;
  updatedFields: String[];
  previousValues: ExpensePreviousValues;
}

export interface ExpenseSubscriptionPayloadPromise
  extends Promise<ExpenseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpensePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpensePreviousValuesPromise>() => T;
}

export interface ExpenseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpensePreviousValuesSubscription>() => T;
}

export interface ExpensePreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExpensePreviousValuesPromise
  extends Promise<ExpensePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExpensePreviousValuesSubscription
  extends Promise<AsyncIterator<ExpensePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NetworkEffectSubscriptionPayload {
  mutation: MutationType;
  node: NetworkEffect;
  updatedFields: String[];
  previousValues: NetworkEffectPreviousValues;
}

export interface NetworkEffectSubscriptionPayloadPromise
  extends Promise<NetworkEffectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NetworkEffectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NetworkEffectPreviousValuesPromise>() => T;
}

export interface NetworkEffectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NetworkEffectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NetworkEffectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NetworkEffectPreviousValuesSubscription>() => T;
}

export interface NetworkEffectPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NetworkEffectPreviousValuesPromise
  extends Promise<NetworkEffectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NetworkEffectPreviousValuesSubscription
  extends Promise<AsyncIterator<NetworkEffectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PatternSubscriptionPayload {
  mutation: MutationType;
  node: Pattern;
  updatedFields: String[];
  previousValues: PatternPreviousValues;
}

export interface PatternSubscriptionPayloadPromise
  extends Promise<PatternSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PatternPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PatternPreviousValuesPromise>() => T;
}

export interface PatternSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PatternSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PatternSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PatternPreviousValuesSubscription>() => T;
}

export interface PatternPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  actorWeight?: Int;
  valuePropositionWeight?: Int;
  valueCreationWeight?: Int;
  valueDeliveryWeight?: Int;
  revenueWeight?: Int;
  expenseWeight?: Int;
  networkEffectWeight?: Int;
  regulatoryWeight?: Int;
  technicalInfrastructureWeight?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PatternPreviousValuesPromise
  extends Promise<PatternPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  actorWeight: () => Promise<Int>;
  valuePropositionWeight: () => Promise<Int>;
  valueCreationWeight: () => Promise<Int>;
  valueDeliveryWeight: () => Promise<Int>;
  revenueWeight: () => Promise<Int>;
  expenseWeight: () => Promise<Int>;
  networkEffectWeight: () => Promise<Int>;
  regulatoryWeight: () => Promise<Int>;
  technicalInfrastructureWeight: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatternPreviousValuesSubscription
  extends Promise<AsyncIterator<PatternPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  actorWeight: () => Promise<AsyncIterator<Int>>;
  valuePropositionWeight: () => Promise<AsyncIterator<Int>>;
  valueCreationWeight: () => Promise<AsyncIterator<Int>>;
  valueDeliveryWeight: () => Promise<AsyncIterator<Int>>;
  revenueWeight: () => Promise<AsyncIterator<Int>>;
  expenseWeight: () => Promise<AsyncIterator<Int>>;
  networkEffectWeight: () => Promise<AsyncIterator<Int>>;
  regulatoryWeight: () => Promise<AsyncIterator<Int>>;
  technicalInfrastructureWeight: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegulatorySubscriptionPayload {
  mutation: MutationType;
  node: Regulatory;
  updatedFields: String[];
  previousValues: RegulatoryPreviousValues;
}

export interface RegulatorySubscriptionPayloadPromise
  extends Promise<RegulatorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegulatoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegulatoryPreviousValuesPromise>() => T;
}

export interface RegulatorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegulatorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegulatorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegulatoryPreviousValuesSubscription>() => T;
}

export interface RegulatoryPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegulatoryPreviousValuesPromise
  extends Promise<RegulatoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RegulatoryPreviousValuesSubscription
  extends Promise<AsyncIterator<RegulatoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RevenueSubscriptionPayload {
  mutation: MutationType;
  node: Revenue;
  updatedFields: String[];
  previousValues: RevenuePreviousValues;
}

export interface RevenueSubscriptionPayloadPromise
  extends Promise<RevenueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RevenuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RevenuePreviousValuesPromise>() => T;
}

export interface RevenueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RevenueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RevenueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RevenuePreviousValuesSubscription>() => T;
}

export interface RevenuePreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RevenuePreviousValuesPromise
  extends Promise<RevenuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RevenuePreviousValuesSubscription
  extends Promise<AsyncIterator<RevenuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StrategySubscriptionPayload {
  mutation: MutationType;
  node: Strategy;
  updatedFields: String[];
  previousValues: StrategyPreviousValues;
}

export interface StrategySubscriptionPayloadPromise
  extends Promise<StrategySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StrategyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StrategyPreviousValuesPromise>() => T;
}

export interface StrategySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StrategySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StrategySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StrategyPreviousValuesSubscription>() => T;
}

export interface StrategyPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StrategyPreviousValuesPromise
  extends Promise<StrategyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StrategyPreviousValuesSubscription
  extends Promise<AsyncIterator<StrategyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StrategyPatternSubscriptionPayload {
  mutation: MutationType;
  node: StrategyPattern;
  updatedFields: String[];
  previousValues: StrategyPatternPreviousValues;
}

export interface StrategyPatternSubscriptionPayloadPromise
  extends Promise<StrategyPatternSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StrategyPatternPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StrategyPatternPreviousValuesPromise>() => T;
}

export interface StrategyPatternSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StrategyPatternSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StrategyPatternSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StrategyPatternPreviousValuesSubscription>() => T;
}

export interface StrategyPatternPreviousValues {
  id: ID_Output;
  weight: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StrategyPatternPreviousValuesPromise
  extends Promise<StrategyPatternPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StrategyPatternPreviousValuesSubscription
  extends Promise<AsyncIterator<StrategyPatternPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TableSubscriptionPayload {
  mutation: MutationType;
  node: Table;
  updatedFields: String[];
  previousValues: TablePreviousValues;
}

export interface TableSubscriptionPayloadPromise
  extends Promise<TableSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TablePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TablePreviousValuesPromise>() => T;
}

export interface TableSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TableSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TableSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TablePreviousValuesSubscription>() => T;
}

export interface TablePreviousValues {
  id: ID_Output;
}

export interface TablePreviousValuesPromise
  extends Promise<TablePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface TablePreviousValuesSubscription
  extends Promise<AsyncIterator<TablePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TechnicalInfrastructureSubscriptionPayload {
  mutation: MutationType;
  node: TechnicalInfrastructure;
  updatedFields: String[];
  previousValues: TechnicalInfrastructurePreviousValues;
}

export interface TechnicalInfrastructureSubscriptionPayloadPromise
  extends Promise<TechnicalInfrastructureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TechnicalInfrastructurePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TechnicalInfrastructurePreviousValuesPromise>() => T;
}

export interface TechnicalInfrastructureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TechnicalInfrastructureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TechnicalInfrastructureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = TechnicalInfrastructurePreviousValuesSubscription
  >() => T;
}

export interface TechnicalInfrastructurePreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TechnicalInfrastructurePreviousValuesPromise
  extends Promise<TechnicalInfrastructurePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TechnicalInfrastructurePreviousValuesSubscription
  extends Promise<AsyncIterator<TechnicalInfrastructurePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  role: Role;
  password: String;
  verificationCode?: String;
  verified: Boolean;
  phoneNumber?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  verificationCode: () => Promise<String>;
  verified: () => Promise<Boolean>;
  phoneNumber: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  password: () => Promise<AsyncIterator<String>>;
  verificationCode: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ValueCreationSubscriptionPayload {
  mutation: MutationType;
  node: ValueCreation;
  updatedFields: String[];
  previousValues: ValueCreationPreviousValues;
}

export interface ValueCreationSubscriptionPayloadPromise
  extends Promise<ValueCreationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValueCreationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ValueCreationPreviousValuesPromise>() => T;
}

export interface ValueCreationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValueCreationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValueCreationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ValueCreationPreviousValuesSubscription>() => T;
}

export interface ValueCreationPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ValueCreationPreviousValuesPromise
  extends Promise<ValueCreationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValueCreationPreviousValuesSubscription
  extends Promise<AsyncIterator<ValueCreationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ValueDeliverySubscriptionPayload {
  mutation: MutationType;
  node: ValueDelivery;
  updatedFields: String[];
  previousValues: ValueDeliveryPreviousValues;
}

export interface ValueDeliverySubscriptionPayloadPromise
  extends Promise<ValueDeliverySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValueDeliveryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ValueDeliveryPreviousValuesPromise>() => T;
}

export interface ValueDeliverySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValueDeliverySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValueDeliverySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ValueDeliveryPreviousValuesSubscription>() => T;
}

export interface ValueDeliveryPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ValueDeliveryPreviousValuesPromise
  extends Promise<ValueDeliveryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValueDeliveryPreviousValuesSubscription
  extends Promise<AsyncIterator<ValueDeliveryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ValuePropositionSubscriptionPayload {
  mutation: MutationType;
  node: ValueProposition;
  updatedFields: String[];
  previousValues: ValuePropositionPreviousValues;
}

export interface ValuePropositionSubscriptionPayloadPromise
  extends Promise<ValuePropositionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValuePropositionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ValuePropositionPreviousValuesPromise>() => T;
}

export interface ValuePropositionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValuePropositionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValuePropositionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ValuePropositionPreviousValuesSubscription>() => T;
}

export interface ValuePropositionPreviousValues {
  id: ID_Output;
  text: String;
  note?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ValuePropositionPreviousValuesPromise
  extends Promise<ValuePropositionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  note: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ValuePropositionPreviousValuesSubscription
  extends Promise<AsyncIterator<ValuePropositionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "Canvas",
    embedded: false
  },
  {
    name: "Pattern",
    embedded: false
  },
  {
    name: "Strategy",
    embedded: false
  },
  {
    name: "StrategyPattern",
    embedded: false
  },
  {
    name: "Table",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Actor",
    embedded: false
  },
  {
    name: "ValueProposition",
    embedded: false
  },
  {
    name: "ValueCreation",
    embedded: false
  },
  {
    name: "ValueDelivery",
    embedded: false
  },
  {
    name: "Revenue",
    embedded: false
  },
  {
    name: "Expense",
    embedded: false
  },
  {
    name: "NetworkEffect",
    embedded: false
  },
  {
    name: "TechnicalInfrastructure",
    embedded: false
  },
  {
    name: "Regulatory",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://canvasprisma-9a0fe0d5ce.herokuapp.com/BusinessModelDigitalHealthBackend/dev`,
  secret: `AiD-CaNvAs-PrOjEcT-2019`
});
export const prisma = new Prisma();
